<!DOCTYPE HTML>
<html lang="en">
<head>
  <meta charset="utf-8">
  
  <title>async函数 | Hexo</title>
  <meta name="author" content="John Doe">
  
  <meta name="description" content="[TOC]
¶async函数

async是generator函数的语法糖

1234567891011121314151617181920212223242526272829303132// 读取文件const fs = require(&#39;fs&#39;); const readFile = functi">
  
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  <meta property="og:title" content="async函数"/>
  <meta property="og:site_name" content="Hexo"/>

  
    <meta property="og:image" content=""/>
  

  <link href="/favicon.png" rel="icon">
  <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
<link rel="stylesheet" href="/css/style.css">

  <!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
  

<meta name="generator" content="Hexo 4.2.1"></head>


<body>
  <header id="header" class="inner"><div class="alignleft">
  <h1><a href="/">Hexo</a></h1>
  <h2><a href="/"></a></h2>
</div>
<nav id="main-nav" class="alignright">
  <ul>
    
      <li><a href="/">Home</a></li>
    
      <li><a href="/archives">Archives</a></li>
    
  </ul>
  <div class="clearfix"></div>
</nav>
<div class="clearfix"></div>
</header>
  <div id="content" class="inner">
    <div id="main-col" class="alignleft"><div id="wrapper"><article id="post-15、async函数" class="h-entry post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time class="dt-published" datetime="2020-07-21T13:58:00.000Z"><a href="/2020/07/21/15、async函数/">2020-07-21</a></time>
      
      
  
    <h1 class="p-name title" itemprop="headline name">async函数</h1>
  

    </header>
    <div class="e-content entry" itemprop="articleBody">
      
        <p>[TOC]</p>
<h2 id="async函数"><a class="header-anchor" href="#async函数">¶</a>async函数</h2>
<ul>
<li>async是generator函数的语法糖</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 读取文件</span></span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>); </span><br><span class="line"><span class="keyword">const</span> readFile = <span class="function"><span class="keyword">function</span> (<span class="params">fileName</span>) </span>&#123; </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123; </span><br><span class="line">        fs.readFile(fileName, <span class="function"><span class="keyword">function</span>(<span class="params">error, data</span>) </span>&#123; </span><br><span class="line">            <span class="keyword">if</span> (error) <span class="keyword">return</span> reject(error); </span><br><span class="line">            resolve(data); </span><br><span class="line">        &#125;); </span><br><span class="line">    &#125;); </span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// generator函数写法</span></span><br><span class="line"><span class="keyword">const</span> gen = <span class="function"><span class="keyword">function</span>* (<span class="params"></span>) </span>&#123; </span><br><span class="line">    <span class="keyword">const</span> f1 = <span class="keyword">yield</span> readFile(<span class="string">'/etc/fstab'</span>); </span><br><span class="line">    <span class="keyword">const</span> f2 = <span class="keyword">yield</span> readFile(<span class="string">'/etc/shells'</span>); </span><br><span class="line">    <span class="built_in">console</span>.log(f1.toString()); </span><br><span class="line">    <span class="built_in">console</span>.log(f2.toString()); </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// async函数写法</span></span><br><span class="line"><span class="keyword">const</span> asyncReadFile = <span class="keyword">async</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; </span><br><span class="line">    <span class="keyword">const</span> f1 = <span class="keyword">await</span> readFile(<span class="string">'/etc/fstab'</span>); </span><br><span class="line">    <span class="keyword">const</span> f2 = <span class="keyword">await</span> readFile(<span class="string">'/etc/shells'</span>); </span><br><span class="line">    <span class="built_in">console</span>.log(f1.toString()); </span><br><span class="line">    <span class="built_in">console</span>.log(f2.toString()); </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将generator函数的*替换成async  将yield替换成await</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// async函数对generator函数的改进  （1）generator函数的执行必须依靠执行器（调用next方法或co模块）而async函数自带执行器 即与普通函数一样  asyncReadFile()</span></span><br><span class="line"><span class="comment">// （2）async和await 比起*和yield  语义更加清楚</span></span><br><span class="line"><span class="comment">// （3）co 模块约定， yield 命令后面只能是 Thunk 函数或 Promise 对象， 而 async 函数的 await 命令后面，可以是Promise 对象和原始类型的 值（数值、字符串和布尔值，但这时等同于同步操作）</span></span><br><span class="line"><span class="comment">// （4）返回值是promise  可以用then方法指定下一步的操作</span></span><br></pre></td></tr></table></figure>
<h3 id="基本用法"><a class="header-anchor" href="#基本用法">¶</a>基本用法</h3>
<ul>
<li>async函数返回一个Promise对象  可以用then方法添加回调函数  当函数执行的时候  一旦遇到await就会先返回  等到异步操作完成  再接着执行函数体内后面的语句</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">timeout</span>(<span class="params">ms</span>) </span>&#123; </span><br><span class="line">    <span class="keyword">await</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123; </span><br><span class="line">        setTimeout(resolve, ms); </span><br><span class="line">    &#125;); </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">asyncPrint</span>(<span class="params">value, ms</span>) </span>&#123; </span><br><span class="line">    <span class="keyword">await</span> timeout(ms); </span><br><span class="line">    <span class="built_in">console</span>.log(value); </span><br><span class="line">&#125;</span><br><span class="line">asyncPrint(<span class="string">'hello world'</span>, <span class="number">50</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数声明</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="comment">// 函数表达式</span></span><br><span class="line"><span class="keyword">const</span> foo = <span class="keyword">async</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line"><span class="comment">// 箭头函数</span></span><br><span class="line"><span class="keyword">const</span> foo = <span class="keyword">async</span> () =&gt; &#123;&#125;;</span><br><span class="line"><span class="comment">// class方法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Storage</span> </span>&#123; </span><br><span class="line">    <span class="keyword">constructor</span>() &#123; </span><br><span class="line">        <span class="keyword">this</span>.cachePromise = caches.open(<span class="string">'avatars'</span>); </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">async</span> getAvatar(name) &#123; </span><br><span class="line">        <span class="keyword">const</span> cache = <span class="keyword">await</span> <span class="keyword">this</span>.cachePromise; </span><br><span class="line">        <span class="keyword">return</span> cache.match(<span class="string">`/avatars/<span class="subst">$&#123;name&#125;</span>.jpg`</span>); </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> storage = <span class="keyword">new</span> Storage(); </span><br><span class="line">storage.getAvatar(<span class="string">'jake'</span>).then(…);</span><br></pre></td></tr></table></figure>
<h3 id="语法"><a class="header-anchor" href="#语法">¶</a>语法</h3>
<h4 id="返回promise对象"><a class="header-anchor" href="#返回promise对象">¶</a>返回promise对象</h4>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// async函数返回一个promise对象  async函数内部return语句返回的值  会成为then方法回调函数的参数</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">    <span class="keyword">return</span> <span class="string">'hello world'</span>; </span><br><span class="line">&#125;</span><br><span class="line">f().then(<span class="function"><span class="params">v</span> =&gt;</span> <span class="built_in">console</span>.log(v)) <span class="comment">// "hello world"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// async函数内部抛出错误  会导致返回的promise对象变为reject状态 抛出的错误会被catch方法回调函数接收</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'出错了'</span>); </span><br><span class="line">&#125;</span><br><span class="line">f().then( </span><br><span class="line">    v =&gt; <span class="built_in">console</span>.log(v), </span><br><span class="line">    e =&gt; <span class="built_in">console</span>.log(e) </span><br><span class="line">)<span class="comment">// Error: 出错了</span></span><br></pre></td></tr></table></figure>
<h4 id="promise对象的状态变化"><a class="header-anchor" href="#promise对象的状态变化">¶</a>promise对象的状态变化</h4>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// async函数返回的promise对象  必须等到内部所有await命令后面的promise对象执行完 才会发生状态改变  除非遇到return语句或抛出错误</span></span><br><span class="line"><span class="comment">// 只有 async 函数内部的异步操作执行完，才会执行 then 方法指定的回调函数</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">getTitle</span>(<span class="params">url</span>) </span>&#123; </span><br><span class="line">    <span class="keyword">let</span> response = <span class="keyword">await</span> fetch(url); </span><br><span class="line">    <span class="keyword">let</span> html = <span class="keyword">await</span> response.text(); </span><br><span class="line">    <span class="keyword">return</span> html.match(<span class="regexp">/&lt;title&gt;([\s\S]+)&lt;\/title&gt;/i</span>)[<span class="number">1</span>]; </span><br><span class="line">&#125;</span><br><span class="line">getTitle(<span class="string">'https://tc39.github.io/ecma262/'</span>).then(<span class="built_in">console</span> .log) </span><br><span class="line"><span class="comment">// "ECMAScript 2017 Language Specification"</span></span><br><span class="line"><span class="comment">// 上述函数存在三个操作  只有等这三个操作全部完成  才会执行then方法里的console.log</span></span><br></pre></td></tr></table></figure>
<h4 id="await命令"><a class="header-anchor" href="#await命令">¶</a>await命令</h4>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 正常情况下 await命令后面是一个promise对象  如果不是 会被转成一个立即resolve的promise对象</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">await</span> <span class="number">123</span>; </span><br><span class="line">&#125;</span><br><span class="line">f().then(<span class="function"><span class="params">v</span> =&gt;</span> <span class="built_in">console</span>.log(v)) <span class="comment">// 123</span></span><br><span class="line"><span class="comment">// 上面代码中 await 命令的参数是数值 123  它被转成 Promise 对象 并立即 resolve</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// await命令后面的promise对象如果变成reject状态  则reject的参数会被catch方法的回调接收到</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">    <span class="keyword">await</span> <span class="built_in">Promise</span>.reject(<span class="string">'出错了'</span>); </span><br><span class="line">&#125;</span><br><span class="line">f()</span><br><span class="line">.then(<span class="function"><span class="params">v</span> =&gt;</span> <span class="built_in">console</span>.log(v))</span><br><span class="line">.catch(<span class="function"><span class="params">e</span> =&gt;</span> <span class="built_in">console</span>.log(e)) <span class="comment">// 出错了</span></span><br><span class="line"><span class="comment">// 只要一个await语句后面的promise变成reject 那么整个async函数都会中断执行</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果希望即使一个异步操作失败 后面也能继续进行 可以使用try...catch</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">    <span class="keyword">try</span> &#123; </span><br><span class="line">        <span class="keyword">await</span> <span class="built_in">Promise</span>.reject(<span class="string">'出错了'</span>); </span><br><span class="line">    &#125; <span class="keyword">catch</span>(e) &#123; &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">await</span> <span class="built_in">Promise</span>.resolve(<span class="string">'hello world'</span>); &#125;</span><br><span class="line">f().then(<span class="function"><span class="params">v</span> =&gt;</span> <span class="built_in">console</span>.log(v)) <span class="comment">// hello world</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 另一种方法是await后面的promise对象再跟一个catch方法  处理前面可能出现的错误</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">    <span class="keyword">await</span> <span class="built_in">Promise</span>.reject(<span class="string">'出错了'</span>).catch(<span class="function"><span class="params">e</span> =&gt;</span> <span class="built_in">console</span>.log(e)); </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">await</span> <span class="built_in">Promise</span>.resolve(<span class="string">'hello world'</span>); </span><br><span class="line">&#125;</span><br><span class="line">f().then(<span class="function"><span class="params">v</span> =&gt;</span> <span class="built_in">console</span>.log(v)) </span><br><span class="line"><span class="comment">// 出错了 </span></span><br><span class="line"><span class="comment">// hello world</span></span><br></pre></td></tr></table></figure>
<h4 id="错误处理"><a class="header-anchor" href="#错误处理">¶</a>错误处理</h4>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果await后面的异步操作出错 等同于async函数返回的promise对象被reject</span></span><br><span class="line"><span class="comment">// 如果有多个await命令 可以统一放在try...catch结构中</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">main</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">    <span class="keyword">try</span> &#123; </span><br><span class="line">        <span class="keyword">const</span> val1 = <span class="keyword">await</span> firstStep(); </span><br><span class="line">        <span class="keyword">const</span> val2 = <span class="keyword">await</span> secondStep(val1); </span><br><span class="line">        <span class="keyword">const</span> val3 = <span class="keyword">await</span> thirdStep(val1, val2); </span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'Final: '</span>, val3); </span><br><span class="line">    &#125;<span class="keyword">catch</span> (err) &#123; </span><br><span class="line">        <span class="built_in">console</span>.error(err); </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 利用try...catch结构 实现多次重复尝试</span></span><br><span class="line"><span class="keyword">const</span> superagent = <span class="built_in">require</span>(<span class="string">'superagent'</span>); </span><br><span class="line"><span class="keyword">const</span> NUM_RETRIES = <span class="number">3</span>; </span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">    <span class="keyword">let</span> i; </span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; NUM_RETRIES; ++i) &#123; </span><br><span class="line">        <span class="keyword">try</span> &#123; </span><br><span class="line">            <span class="keyword">await</span> superagent.get(<span class="string">'http://google.com/this- throws-an-error'</span>); </span><br><span class="line">            <span class="keyword">break</span>; </span><br><span class="line">        &#125; <span class="keyword">catch</span>(err) &#123;&#125; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">console</span>.log(i); <span class="comment">// 3 </span></span><br><span class="line">&#125;</span><br><span class="line">test();</span><br><span class="line"><span class="comment">// 如果await成功 就会break语句退出循环 如果失败就会被catch语句捕获 进入下一轮循环</span></span><br></pre></td></tr></table></figure>
<h3 id="使用注意点"><a class="header-anchor" href="#使用注意点">¶</a>使用注意点</h3>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// （1）最好把await命令放在try...catch中</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">myFunction</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">    <span class="keyword">try</span> &#123; </span><br><span class="line">        <span class="keyword">await</span> somethingThatReturnsAPromise(); </span><br><span class="line">    &#125; <span class="keyword">catch</span> (err) &#123; </span><br><span class="line">        <span class="built_in">console</span>.log(err); </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 另一种写法 </span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">myFunction</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">    <span class="keyword">await</span> somethingThatReturnsAPromise().catch(<span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123; </span><br><span class="line">        <span class="built_in">console</span>.log(err); </span><br><span class="line">    &#125;); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// （2）多个await命令后面的异步操作 如果不存在继发关系 最好同时触发</span></span><br><span class="line"><span class="comment">// 继发</span></span><br><span class="line"><span class="keyword">let</span> foo = <span class="keyword">await</span> getFoo(); </span><br><span class="line"><span class="keyword">let</span> bar = <span class="keyword">await</span> getBar();</span><br><span class="line"><span class="comment">// 写法一</span></span><br><span class="line"><span class="keyword">let</span> [foo, bar] = <span class="keyword">await</span> <span class="built_in">Promise</span>.all([getFoo(), getBar()]);</span><br><span class="line"><span class="comment">// 写法二</span></span><br><span class="line"><span class="keyword">let</span> fooPromise = getFoo(); </span><br><span class="line"><span class="keyword">let</span> barPromise = getBar(); </span><br><span class="line"><span class="keyword">let</span> foo = <span class="keyword">await</span> fooPromise; </span><br><span class="line"><span class="keyword">let</span> bar = <span class="keyword">await</span> barPromise;</span><br><span class="line"></span><br><span class="line"><span class="comment">// （3）await命令只能用在async函数中 如果用在普通函数会报错</span></span><br></pre></td></tr></table></figure>
<h3 id="async函数的实现原理"><a class="header-anchor" href="#async函数的实现原理">¶</a>async函数的实现原理</h3>
<ul>
<li>将generator函数和自动执行器 包装在一个函数里</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">args</span>) </span>&#123; </span><br><span class="line">    <span class="comment">// ... </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 等同于 </span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">args</span>) </span>&#123; </span><br><span class="line">    <span class="keyword">return</span> spawn(<span class="function"><span class="keyword">function</span>* (<span class="params"></span>) </span>&#123; </span><br><span class="line">        <span class="comment">// ... </span></span><br><span class="line">    &#125;); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// spawn函数就是自动执行器  下面是实现原理</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">spawn</span>(<span class="params">genF</span>) </span>&#123; </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123; </span><br><span class="line">        <span class="keyword">const</span> gen = genF(); </span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">step</span>(<span class="params">nextF</span>) </span>&#123; </span><br><span class="line">            <span class="keyword">let</span> next; </span><br><span class="line">            <span class="keyword">try</span> &#123; </span><br><span class="line">                next = nextF(); </span><br><span class="line">            &#125; <span class="keyword">catch</span>(e) &#123; </span><br><span class="line">                <span class="keyword">return</span> reject(e); </span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(next.done) &#123; </span><br><span class="line">                <span class="keyword">return</span> resolve(next.value);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">Promise</span>.resolve(next.value).then(<span class="function"><span class="keyword">function</span>(<span class="params">v</span>) </span>&#123; </span><br><span class="line">                step(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">                    <span class="keyword">return</span> gen.next(v); </span><br><span class="line">                &#125;); </span><br><span class="line">            &#125;, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123; </span><br><span class="line">                step(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">                    <span class="keyword">return</span> gen.throw(e); </span><br><span class="line">                &#125;); </span><br><span class="line">            &#125;); </span><br><span class="line">        &#125;step(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">            <span class="keyword">return</span> gen.next(<span class="literal">undefined</span>); </span><br><span class="line">        &#125;); </span><br><span class="line">    &#125;); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="与其他异步处理方法的比较"><a class="header-anchor" href="#与其他异步处理方法的比较">¶</a>与其他异步处理方法的比较</h3>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// promise</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">chainAnimationsPromise</span>(<span class="params">elem, animations</span>) </span>&#123; </span><br><span class="line">    <span class="comment">// 变量ret用来保存上一个动画的返回值 </span></span><br><span class="line">    <span class="keyword">let</span> ret = <span class="literal">null</span>; </span><br><span class="line">    <span class="comment">// 新建一个空的Promise </span></span><br><span class="line">    <span class="keyword">let</span> p = <span class="built_in">Promise</span>.resolve(); </span><br><span class="line">    <span class="comment">// 使用then方法，添加所有动画 </span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> anim <span class="keyword">of</span> animations) &#123; </span><br><span class="line">        p = p.then(<span class="function"><span class="keyword">function</span>(<span class="params">val</span>) </span>&#123; </span><br><span class="line">            ret = val; </span><br><span class="line">            <span class="keyword">return</span> anim(elem); </span><br><span class="line">        &#125;); </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回一个部署了错误捕捉机制的Promise </span></span><br><span class="line">    <span class="keyword">return</span> p.catch(<span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123; </span><br><span class="line">        <span class="comment">/* 忽略错误，继续执行 */</span> </span><br><span class="line">    &#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">        <span class="keyword">return</span> ret; </span><br><span class="line">    &#125;); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// generator函数  spawn是自动执行器</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">chainAnimationsGenerator</span>(<span class="params">elem, animations</span>) </span>&#123; </span><br><span class="line">    <span class="keyword">return</span> spawn(<span class="function"><span class="keyword">function</span>*(<span class="params"></span>) </span>&#123; </span><br><span class="line">        <span class="keyword">let</span> ret = <span class="literal">null</span>; </span><br><span class="line">        <span class="keyword">try</span> &#123; </span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">let</span> anim <span class="keyword">of</span> animations) &#123; </span><br><span class="line">                ret = <span class="keyword">yield</span> anim(elem); </span><br><span class="line">            &#125; </span><br><span class="line">        &#125; <span class="keyword">catch</span>(e) &#123; </span><br><span class="line">            <span class="comment">/* 忽略错误，继续执行 */</span> </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret; </span><br><span class="line">    &#125;); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// async函数</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">chainAnimationsAsync</span>(<span class="params">elem, animations</span>) </span>&#123; </span><br><span class="line">    <span class="keyword">let</span> ret = <span class="literal">null</span>; </span><br><span class="line">    <span class="keyword">try</span> &#123; </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> anim <span class="keyword">of</span> animations) &#123; </span><br><span class="line">            ret = <span class="keyword">await</span> anim(elem); </span><br><span class="line">        &#125; </span><br><span class="line">    &#125; <span class="keyword">catch</span>(e) &#123; </span><br><span class="line">        <span class="comment">/* 忽略错误，继续执行 */</span> </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>
    <footer>
      
        
        
  
  <div class="tags">
    <a href="/tags/es6/">es6</a>
  </div>

        
  <div class="addthis addthis_toolbox addthis_default_style">
    
      <a class="addthis_button_facebook_like" fb:like:layout="button_count"></a>
    
    
      <a class="addthis_button_tweet"></a>
    
    
      <a class="addthis_button_google_plusone" g:plusone:size="medium"></a>
    
    
      <a class="addthis_button_pinterest_pinit" pi:pinit:layout="horizontal"></a>
    
    <a class="addthis_counter addthis_pill_style"></a>
  </div>
  <script type="text/javascript" src="//s7.addthis.com/js/300/addthis_widget.js"></script>

      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>


<section id="comment">
  <h1 class="title">Comments</h1>

  
      <div id="fb-root"></div>
<script>
  (function(d, s, id) {
    var js, fjs = d.getElementsByTagName(s)[0];
    if (d.getElementById(id)) return;
    js = d.createElement(s); js.id = id;
    js.src = "//connect.facebook.net/en_US/all.js#xfbml=1&appId=123456789012345";
    fjs.parentNode.insertBefore(js, fjs);
  }(document, 'script', 'facebook-jssdk'));
</script>

<div class="fb-comments" data-href="http://yoursite.com/2020/07/21/15%E3%80%81async%E5%87%BD%E6%95%B0/index.html" data-num-posts="5" data-width="840" data-colorscheme="light"></div>
      
  
</section>

</div></div>
    <aside id="sidebar" class="alignright">
  <div class="search">
  <form action="//google.com/search" method="get" accept-charset="utf-8">
    <input type="search" name="q" results="0" placeholder="Search">
    <input type="hidden" name="as_sitesearch" value="yoursite.com">
  </form>
</div>


  

  
<div class="widget tag">
  <h3 class="title">Tags</h3>
  <ul class="entry">
  
    <li><a href="/tags/JavaScript/">JavaScript</a><small>3</small></li>
  
    <li><a href="/tags/es6/">es6</a><small>9</small></li>
  
    <li><a href="/tags/git/">git</a><small>1</small></li>
  
  </ul>
</div>

</aside>
    <div class="clearfix"></div>
  </div>
  <footer id="footer" class="inner"><div class="alignleft">
  
  &copy; 2020 John Doe
  
</div>
<div class="clearfix"></div></footer>
  
<script src="/js/jquery-3.4.1.min.js"></script>


<script src="/js/jquery.imagesloaded.min.js"></script>


<script src="/js/gallery.js"></script>






<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">


<script src="/fancybox/jquery.fancybox.pack.js"></script>

<script type="text/javascript">
(function($){
  $('.fancybox').fancybox();
})(jQuery);
</script>

</body>
</html>

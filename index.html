<!DOCTYPE HTML>
<html lang="en">
<head>
  <meta charset="utf-8">
  
  <title>Hexo</title>
  <meta name="author" content="John Doe">
  
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  
  <meta property="og:site_name" content="Hexo"/>

  
    <meta property="og:image" content=""/>
  

  <link href="/favicon.png" rel="icon">
  <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
<link rel="stylesheet" href="/css/style.css">

  <!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
  

<meta name="generator" content="Hexo 4.2.1"></head>


<body>
  <header id="header" class="inner"><div class="alignleft">
  <h1><a href="/">Hexo</a></h1>
  <h2><a href="/"></a></h2>
</div>
<nav id="main-nav" class="alignright">
  <ul>
    
      <li><a href="/">Home</a></li>
    
      <li><a href="/archives">Archives</a></li>
    
  </ul>
  <div class="clearfix"></div>
</nav>
<div class="clearfix"></div>
</header>
  <div id="content" class="inner">
    <div id="main-col" class="alignleft"><div id="wrapper">
  <article id="post-4、正则扩展" class="h-entry post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time class="dt-published" datetime="2020-07-28T13:13:55.000Z"><a href="/2020/07/28/4、正则扩展/">2020-07-28</a></time>
      
      
  
    <h1 class="title"><a href="/2020/07/28/4、正则扩展/">4、正则扩展</a></h1>
  

    </header>
    <div class="e-content entry" itemprop="articleBody">
      
        <p>[TOC]</p>
<h2 id="正则扩展"><a class="header-anchor" href="#正则扩展">¶</a>正则扩展</h2>
<h3 id="RegExp构造函数"><a class="header-anchor" href="#RegExp构造函数">¶</a>RegExp构造函数</h3>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// es5 构造函数的参数有两种方式 第二种不允许使用第二个参数添加修饰符 否则会报错</span></span><br><span class="line"><span class="comment">// 一</span></span><br><span class="line"><span class="keyword">var</span> regex = <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">'xyz'</span>, <span class="string">'i'</span>); </span><br><span class="line"><span class="comment">// 等价于 </span></span><br><span class="line"><span class="keyword">var</span> regex = <span class="regexp">/xyz/i</span></span><br><span class="line"><span class="comment">// 二</span></span><br><span class="line"><span class="keyword">var</span> regex = <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="regexp">/xyz/i</span>); </span><br><span class="line"><span class="comment">// 等价于 </span></span><br><span class="line"><span class="keyword">var</span> regex = <span class="regexp">/xyz/i</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// es6 第一个参数中的修饰符会被第二个参数覆盖</span></span><br><span class="line"><span class="keyword">var</span> 变量 = <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="regexp">/abc/ig</span>, <span class="string">'i'</span>)</span><br><span class="line"><span class="comment">// 等价于</span></span><br><span class="line"><span class="keyword">var</span> 变量 = <span class="regexp">/abc/i</span></span><br></pre></td></tr></table></figure>
<h3 id="u修饰符"><a class="header-anchor" href="#u修饰符">¶</a>u修饰符</h3>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// u修饰符用于处理大于 \uFFFF 的Unicode字符</span></span><br><span class="line">/^\uD83D/u.test(<span class="string">'\uD83D\uDC2A'</span>) <span class="comment">// false </span></span><br><span class="line">/^\uD83D/.test(<span class="string">'\uD83D\uDC2A'</span>) <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// （1）点字符 含义是除了换行符以外的任意单个字符。对于码点大于 0xFFFF 的 Unicode 字符，点字符不能识别，必须加上 u 修饰符</span></span><br><span class="line"><span class="keyword">var</span> s = <span class="string">'𠮷'</span>;</span><br><span class="line">/^.$/.test(s) <span class="comment">// false</span></span><br><span class="line">/^.$/u.test(s) <span class="comment">// true</span></span><br><span class="line"><span class="comment">// 如果不添加u修饰符 正则表达式会认为字符串为两个字符 从而匹配失败</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// （2）Unicode字符表示法 大括号表示法需要u修饰符才能识别</span></span><br><span class="line">/\u&#123;<span class="number">61</span>&#125;/.test(<span class="string">'a'</span>) <span class="comment">// false</span></span><br><span class="line">/\u&#123;<span class="number">61</span>&#125;/u.test(<span class="string">'a'</span>) <span class="comment">// true</span></span><br><span class="line">/\u&#123;<span class="number">20</span>BB7&#125;/u.test(<span class="string">'𠮷'</span>) <span class="comment">// true</span></span><br><span class="line"><span class="comment">// 如果不加u修饰符 正则会认为匹配61个连续的u</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// （3）量词  使用u修饰符后 所有量词都会正确识别码点大于0xFFFF的Unicode字符</span></span><br><span class="line">/a&#123;<span class="number">2</span>&#125;/.test(<span class="string">'aa'</span>) <span class="comment">// true</span></span><br><span class="line">/a&#123;<span class="number">2</span>&#125;/u.test(<span class="string">'aa'</span>) <span class="comment">// true</span></span><br><span class="line">/𠮷&#123;<span class="number">2</span>&#125;/.test(<span class="string">'𠮷𠮷'</span>) <span class="comment">// false</span></span><br><span class="line">/𠮷&#123;<span class="number">2</span>&#125;/u.test(<span class="string">'𠮷𠮷'</span>) <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// （4）预定义模式 u修饰符也影响预定义模式 能否识别码点大于0xFFFF的Unicode字符</span></span><br><span class="line">/^\S$/.test(<span class="string">'𠮷'</span>) <span class="comment">// false</span></span><br><span class="line">/^\S$/u.test(<span class="string">'𠮷'</span>) <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// i修饰符  有些Unicode字符的编码不同 但字形很相近  比如，\u004B与\u212A都是大写的K</span></span><br><span class="line">/[a-z]/i.test(<span class="string">'\u212A'</span>) <span class="comment">// false</span></span><br><span class="line">/[a-z]/iu.test(<span class="string">'\u212A'</span>) <span class="comment">// true</span></span><br><span class="line"><span class="comment">// 加上u修饰符 可以识别非规范的K字符</span></span><br></pre></td></tr></table></figure>
<h3 id="y修饰符"><a class="header-anchor" href="#y修饰符">¶</a>y修饰符</h3>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// （1）y修饰符的作用与g修饰符类似，也是全局匹配，后一次匹配都从上一次匹配成功的下一个位置开始。不同之处在于，g修饰符只要剩余位置中存在匹配就可，而y修饰符确保匹配必须从剩余的第一个位置开始，这也就是“粘连”的涵义（剩余的第一个位置）</span></span><br><span class="line"><span class="keyword">var</span> s = <span class="string">'aaa_aa_a'</span>;</span><br><span class="line"><span class="keyword">var</span> r1 = <span class="regexp">/a+/g</span>;</span><br><span class="line"><span class="keyword">var</span> r2 = <span class="regexp">/a+/y</span>;</span><br><span class="line"></span><br><span class="line">r1.exec(s) <span class="comment">// ["aaa"]</span></span><br><span class="line">r2.exec(s) <span class="comment">// ["aaa"]</span></span><br><span class="line"></span><br><span class="line">r1.exec(s) <span class="comment">// ["aa"]</span></span><br><span class="line">r2.exec(s) <span class="comment">// null</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// （2）在split方法中使用y修饰符，原字符串必须以分隔符开头。这也意味着，只要匹配成功，数组的第一个成员肯定是空字符串  后续的分隔符只有紧跟前面的分隔符，才会被识别</span></span><br><span class="line"><span class="comment">// 没有找到匹配</span></span><br><span class="line"><span class="string">'x##'</span>.split(<span class="regexp">/#/y</span>)</span><br><span class="line"><span class="comment">// [ 'x##' ]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 找到两个匹配</span></span><br><span class="line"><span class="string">'##x'</span>.split(<span class="regexp">/#/y</span>)</span><br><span class="line"><span class="comment">// [ '', '', 'x' ]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// （3）单单一个y修饰符对match方法，只能返回第一个匹配，必须与g修饰符联用，才能返回所有匹配</span></span><br><span class="line"><span class="string">'a1a2a3'</span>.match(<span class="regexp">/a\d/y</span>) <span class="comment">// ["a1"]</span></span><br><span class="line"><span class="string">'a1a2a3'</span>.match(<span class="regexp">/a\d/gy</span>) <span class="comment">// ["a1", "a2", "a3"]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// （4） 应用：y修饰符的一个应用，是从字符串提取token（词元），y修饰符确保了匹配之间不会有漏掉的字符。</span></span><br><span class="line"><span class="keyword">const</span> TOKEN_Y = <span class="regexp">/\s*(\+|[0-9]+)\s*/y</span>;</span><br><span class="line"><span class="keyword">const</span> TOKEN_G  = <span class="regexp">/\s*(\+|[0-9]+)\s*/g</span>;</span><br><span class="line"></span><br><span class="line">tokenize(TOKEN_Y, <span class="string">'3 + 4'</span>)</span><br><span class="line"><span class="comment">// [ '3', '+', '4' ]</span></span><br><span class="line">tokenize(TOKEN_G, <span class="string">'3 + 4'</span>)</span><br><span class="line"><span class="comment">// [ '3', '+', '4' ]</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">tokenize</span>(<span class="params">TOKEN_REGEX, str</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> result = [];</span><br><span class="line">  <span class="keyword">let</span> match;</span><br><span class="line">  <span class="keyword">while</span> (match = TOKEN_REGEX.exec(str)) &#123;</span><br><span class="line">    result.push(match[<span class="number">1</span>]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 没有非法字符时提取结果是一样的  当出现非法字符 行为不一样</span></span><br><span class="line">tokenize(TOKEN_Y, <span class="string">'3x + 4'</span>)</span><br><span class="line"><span class="comment">// [ '3' ]</span></span><br><span class="line">tokenize(TOKEN_G, <span class="string">'3x + 4'</span>)</span><br><span class="line"><span class="comment">// [ '3', '+', '4' ]</span></span><br></pre></td></tr></table></figure>
<h3 id="属性"><a class="header-anchor" href="#属性">¶</a>属性</h3>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// sticky属性  表示是否设置了y修饰符 返回bool</span></span><br><span class="line"><span class="keyword">var</span> r = <span class="regexp">/hello\d/y</span>;</span><br><span class="line">r.sticky <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// flags属性 返回正则表达式的修饰符</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ES5的source属性</span></span><br><span class="line"><span class="comment">// 返回正则表达式的正文</span></span><br><span class="line">/abc/ig.source</span><br><span class="line"><span class="comment">// "abc"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ES6的flags属性</span></span><br><span class="line"><span class="comment">// 返回正则表达式的修饰符</span></span><br><span class="line">/abc/ig.flags</span><br><span class="line"><span class="comment">// 'gi'</span></span><br></pre></td></tr></table></figure>
<h3 id="将字符串转义-作为正则模式"><a class="header-anchor" href="#将字符串转义-作为正则模式">¶</a>将字符串转义 作为正则模式</h3>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 实现的函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">escapeRegExp</span>(<span class="params">str</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> str.replace(<span class="regexp">/[\-\[\]\/\&#123;\&#125;\(\)\*\+\?\.\\\^\$\|]/g</span>, <span class="string">'\\$&amp;'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> str = <span class="string">'/path/to/resource.html?search=query'</span>;</span><br><span class="line">escapeRegExp(str)</span><br><span class="line"><span class="comment">// "\/path\/to\/resource\.html\?search=query"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// RegExp.escape()</span></span><br><span class="line"><span class="built_in">RegExp</span>.escape(<span class="string">'The Quick Brown Fox'</span>);</span><br><span class="line"><span class="comment">// "The Quick Brown Fox"</span></span><br><span class="line"><span class="built_in">RegExp</span>.escape(<span class="string">'Buy it. use it. break it. fix it.'</span>);</span><br><span class="line"><span class="comment">// "Buy it\. use it\. break it\. fix it\."</span></span><br><span class="line"><span class="built_in">RegExp</span>.escape(<span class="string">'(*.*)'</span>);</span><br><span class="line"><span class="comment">// "\(\*\.\*\)"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 字符串转义后 可以使用RegExp构造函数生成正则模式</span></span><br><span class="line"><span class="keyword">var</span> str = <span class="string">'hello. how are you?'</span>;</span><br><span class="line"><span class="keyword">var</span> regex = <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="built_in">RegExp</span>.escape(str), <span class="string">'g'</span>);</span><br><span class="line">assert.equal(<span class="built_in">String</span>(regex), <span class="string">'/hello\. how are you\?/g'</span>);</span><br></pre></td></tr></table></figure>
<h3 id="s修饰符"><a class="header-anchor" href="#s修饰符">¶</a>s修饰符</h3>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在正则中 点字符代表任意的单字符 但行终止符除外</span></span><br><span class="line">/foo.bar/.test(<span class="string">'foo\nbar'</span>)</span><br><span class="line"><span class="comment">// false  .不匹配\n</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 引入s修饰符 使得.可以陪陪任意单个字符</span></span><br><span class="line">/foo.bar/s.test(<span class="string">'foo\nbar'</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article id="post-19、编程风格" class="h-entry post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time class="dt-published" datetime="2020-07-27T11:53:24.000Z"><a href="/2020/07/27/19、编程风格/">2020-07-27</a></time>
      
      
  
    <h1 class="title"><a href="/2020/07/27/19、编程风格/">19、编程风格</a></h1>
  

    </header>
    <div class="e-content entry" itemprop="articleBody">
      
        <p>[TOC]</p>
<h2 id="编程风格"><a class="header-anchor" href="#编程风格">¶</a>编程风格</h2>
<h3 id="块级作用域"><a class="header-anchor" href="#块级作用域">¶</a>块级作用域</h3>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// （1）let取代var  let没有副作用</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// （2）全局常量和线程安全  在let和const之间 优先使用const 在全局环境 不应该设置变量 只应设置常量  const有利于提升运行效率  所有函数都应设置为常量</span></span><br></pre></td></tr></table></figure>
<h3 id="字符串"><a class="header-anchor" href="#字符串">¶</a>字符串</h3>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// （1）静态字符串一律使用单引号或反引号  不使用双引号  动态字符串使用反引号</span></span><br><span class="line"><span class="keyword">const</span> a = <span class="string">'foobar'</span>  <span class="comment">// 静态字符串 </span></span><br><span class="line"><span class="keyword">const</span> b = <span class="string">`foo<span class="subst">$&#123;a&#125;</span>bar`</span>  <span class="comment">// 动态字符串</span></span><br></pre></td></tr></table></figure>
<h3 id="解构赋值"><a class="header-anchor" href="#解构赋值">¶</a>解构赋值</h3>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// （1）使用数组成员对变量赋值  优先使用解构赋值</span></span><br><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line"><span class="keyword">const</span> [first, second] = arr</span><br><span class="line"></span><br><span class="line"><span class="comment">// （2）函数的参数如果是对象的成员  优先使用解构赋值  如果函数返回多个值  优先使用对象的解构赋值  而不是数组的解构赋值 这样便于以后添加返回值 以及更改返回值的顺序</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getFullName</span>(<span class="params">&#123; firstName, lastName &#125;</span>) </span>&#123; </span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">processInput</span>(<span class="params">input</span>) </span>&#123; </span><br><span class="line">    <span class="keyword">return</span> &#123; left, right, top, bottom &#125;; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> &#123; left, right &#125; = processInput(input)</span><br></pre></td></tr></table></figure>
<h3 id="对象"><a class="header-anchor" href="#对象">¶</a>对象</h3>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// （1）单行定义的对象 最后一个成员不以逗号结尾  多行定义的对象 最后一个成员以逗号结尾</span></span><br><span class="line"><span class="keyword">const</span> a = &#123; <span class="attr">k1</span>: v1, <span class="attr">k2</span>: v2 &#125;; </span><br><span class="line"><span class="keyword">const</span> b = &#123; </span><br><span class="line">    k1: v1, </span><br><span class="line">    k2: v2, </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// （2）对象尽量静态化 一旦定义不得随意添加新属性 如果添加属性 不可避免 要使用Object.assign方法</span></span><br><span class="line"><span class="comment">// if reshape unavoidable </span></span><br><span class="line"><span class="keyword">const</span> a = &#123;&#125;; </span><br><span class="line"><span class="built_in">Object</span>.assign(a, &#123; <span class="attr">x</span>: <span class="number">3</span> &#125;); </span><br><span class="line"><span class="comment">// good </span></span><br><span class="line"><span class="keyword">const</span> a = &#123; <span class="attr">x</span>: <span class="literal">null</span> &#125;; </span><br><span class="line">a.x = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// （3）如果对象的属性名是动态的 可以在创造对象的时候 使用属性表达式定义</span></span><br><span class="line"><span class="comment">// good </span></span><br><span class="line"><span class="keyword">const</span> obj = &#123; </span><br><span class="line">    id: <span class="number">5</span>, </span><br><span class="line">    name: <span class="string">'San Francisco'</span>, </span><br><span class="line">    [函数(<span class="string">'enabled'</span>)]: <span class="literal">true</span>, </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// （4）对象的属性和方法 尽量采用简介表达法</span></span><br><span class="line"><span class="keyword">const</span> atom = &#123; </span><br><span class="line">    ref, </span><br><span class="line">    value: <span class="number">1</span>, </span><br><span class="line">    addValue(value) &#123; </span><br><span class="line">        <span class="keyword">return</span> atom.value + value; </span><br><span class="line">    &#125;, </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="数组"><a class="header-anchor" href="#数组">¶</a>数组</h3>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// （1）使用扩展运算符拷贝数组</span></span><br><span class="line"><span class="keyword">const</span> itemsCopy = [...items]</span><br><span class="line"></span><br><span class="line"><span class="comment">// （2）使用Array.from方法 将类数组对象转为数组</span></span><br><span class="line"><span class="keyword">const</span> foo = <span class="built_in">document</span>.querySelectorAll(<span class="string">'.foo'</span>); </span><br><span class="line"><span class="keyword">const</span> nodes = <span class="built_in">Array</span>.from(foo)</span><br></pre></td></tr></table></figure>
<h3 id="函数"><a class="header-anchor" href="#函数">¶</a>函数</h3>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// （1）立即执行函数可以写成箭头函数的形式</span></span><br><span class="line">(<span class="function"><span class="params">()</span> =&gt;</span> &#123; </span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Welcome to the Internet.'</span>); </span><br><span class="line">&#125;)()</span><br><span class="line"></span><br><span class="line"><span class="comment">// （2）需要使用函数表达式的场合  尽量使用箭头函数代替（绑定了this）</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].map(<span class="function"><span class="params">x</span> =&gt;</span> x * x)</span><br><span class="line"></span><br><span class="line"><span class="comment">// （3）箭头函数取代Function.prototype.bind 不应再使用变量绑定this</span></span><br><span class="line"><span class="comment">// bad </span></span><br><span class="line"><span class="keyword">const</span> self = <span class="keyword">this</span>; </span><br><span class="line"><span class="keyword">const</span> boundMethod = <span class="function"><span class="keyword">function</span>(<span class="params">...params</span>) </span>&#123; </span><br><span class="line">    <span class="keyword">return</span> method.apply(self, params); </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// acceptable </span></span><br><span class="line"><span class="keyword">const</span> boundMethod = method.bind(<span class="keyword">this</span>); </span><br><span class="line"><span class="comment">// best </span></span><br><span class="line"><span class="keyword">const</span> boundMethod = <span class="function">(<span class="params">...params</span>) =&gt;</span> method.apply(<span class="keyword">this</span>, params)</span><br><span class="line"></span><br><span class="line"><span class="comment">// （4）简单的 单行的 不会复用的函数 建议采用箭头函数 如果函数比较复杂 行数较多 应该采用传统函数的写法</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// （5）所有配置项都应该集中在一个对象 放在最后一个参数 布尔值不可以直接作为参数</span></span><br><span class="line"><span class="comment">// bad </span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">divide</span>(<span class="params">a, b, option = false </span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// good </span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">divide</span>(<span class="params">a, b, &#123; option = false &#125; = &#123;&#125;</span>) </span>&#123; </span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// （6）不要在函数体内使用arguments变量 使用rest运算符代替 rest运算符显示表明你想要获取参数 而arguments是一个类数组对象 rest运算符可以提供一个真正的数组</span></span><br><span class="line"><span class="comment">// bad </span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">concatenateAll</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">    <span class="keyword">const</span> args = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>); </span><br><span class="line">    <span class="keyword">return</span> args.join(<span class="string">''</span>); </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// good </span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">concatenateAll</span>(<span class="params">...args</span>) </span>&#123; </span><br><span class="line">    <span class="keyword">return</span> args.join(<span class="string">''</span>); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// （7）使用默认值语法设置函数参数的默认值</span></span><br><span class="line"><span class="comment">// bad </span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">handleThings</span>(<span class="params">opts</span>) </span>&#123; </span><br><span class="line">    opts = opts || &#123;&#125;; </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// good </span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">handleThings</span>(<span class="params">opts = &#123;&#125;</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// ... </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Map结构"><a class="header-anchor" href="#Map结构">¶</a>Map结构</h3>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注意区分Object和Map，只有模拟现实世界的实体对象时，才使用 Object。如果只是需要 key: value 的数据结构，使用Map结构。因为 Map有内建的遍历机制</span></span><br><span class="line"><span class="keyword">let</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>(arr); </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">of</span> map.keys()) &#123; </span><br><span class="line">    <span class="built_in">console</span>.log(key); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> value <span class="keyword">of</span> map.values()) &#123; </span><br><span class="line">    <span class="built_in">console</span>.log(value); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> item <span class="keyword">of</span> map.entries()) &#123; </span><br><span class="line">    <span class="built_in">console</span>.log(item[<span class="number">0</span>], item[<span class="number">1</span>]); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Class"><a class="header-anchor" href="#Class">¶</a>Class</h3>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// （1）总是用Class取代需要prototype的操作 因为Class的写法更简单 更易于理解</span></span><br><span class="line"><span class="comment">// bad </span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Queue</span>(<span class="params">contents = []</span>) </span>&#123; </span><br><span class="line">    <span class="keyword">this</span>._queue = [...contents]; </span><br><span class="line">&#125;</span><br><span class="line">Queue.prototype.pop = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">    <span class="keyword">const</span> value = <span class="keyword">this</span>._queue[<span class="number">0</span>]; </span><br><span class="line">    <span class="keyword">this</span>._queue.splice(<span class="number">0</span>, <span class="number">1</span>); </span><br><span class="line">    <span class="keyword">return</span> value; </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// good </span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Queue</span> </span>&#123; </span><br><span class="line">    <span class="keyword">constructor</span>(contents = []) &#123; </span><br><span class="line">        <span class="keyword">this</span>._queue = [...contents]; </span><br><span class="line">    &#125;</span><br><span class="line">    pop() &#123; </span><br><span class="line">        <span class="keyword">const</span> value = <span class="keyword">this</span>._queue[<span class="number">0</span>]; </span><br><span class="line">        <span class="keyword">this</span>._queue.splice(<span class="number">0</span>, <span class="number">1</span>); </span><br><span class="line">        <span class="keyword">return</span> value; </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// （2）使用extends实现继承 这样不会破坏instanceof运算的危险</span></span><br><span class="line"><span class="comment">// bad </span></span><br><span class="line"><span class="keyword">const</span> inherits = <span class="built_in">require</span>(<span class="string">'inherits'</span>); </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">PeekableQueue</span>(<span class="params">contents</span>) </span>&#123; </span><br><span class="line">    Queue.apply(<span class="keyword">this</span>, contents); </span><br><span class="line">&#125;</span><br><span class="line">inherits(PeekableQueue, Queue); </span><br><span class="line">PeekableQueue.prototype.peek = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>._queue[<span class="number">0</span>]; </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// good </span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PeekableQueue</span> <span class="keyword">extends</span> <span class="title">Queue</span> </span>&#123; </span><br><span class="line">    peek() &#123; </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>._queue[<span class="number">0</span>]; </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="模块"><a class="header-anchor" href="#模块">¶</a>模块</h3>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// （1）使用import取代require</span></span><br><span class="line"><span class="comment">// bad </span></span><br><span class="line"><span class="keyword">const</span> moduleA = <span class="built_in">require</span>(<span class="string">'moduleA'</span>); </span><br><span class="line"><span class="keyword">const</span> func1 = moduleA.func1; </span><br><span class="line"><span class="keyword">const</span> func2 = moduleA.func2; </span><br><span class="line"><span class="comment">// good </span></span><br><span class="line"><span class="keyword">import</span> &#123; func1, func2 &#125; <span class="keyword">from</span> <span class="string">'moduleA'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// （2）使用export取代module.exports</span></span><br><span class="line"><span class="comment">// commonJS的写法 </span></span><br><span class="line"><span class="keyword">var</span> React = <span class="built_in">require</span>(<span class="string">'react'</span>); </span><br><span class="line"><span class="keyword">var</span> Breadcrumbs = React.createClass(&#123; </span><br><span class="line">    render() &#123; </span><br><span class="line">        <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">nav</span> /&gt;</span></span>; </span><br><span class="line">    &#125; </span><br><span class="line">&#125;); </span><br><span class="line"><span class="built_in">module</span>.exports = Breadcrumbs; </span><br><span class="line"><span class="comment">// ES6的写法 </span></span><br><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>; </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Breadcrumbs</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123; </span><br><span class="line">    render() &#123; </span><br><span class="line">        <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">nav</span> /&gt;</span></span>; </span><br><span class="line">    &#125; </span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> Breadcrumbs;</span><br><span class="line"></span><br><span class="line"><span class="comment">// （3）模块只有一个输出值  使用export default 多个输出值 不使用export default  export default 与普通的export不要同时使用</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// （4）不要在模块中使用通配符 这样可以确保模块中 有一个默认输出</span></span><br><span class="line"><span class="comment">// bad </span></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> myObject <span class="keyword">from</span> <span class="string">'./importModule'</span>; </span><br><span class="line"><span class="comment">// good </span></span><br><span class="line"><span class="keyword">import</span> myObject <span class="keyword">from</span> <span class="string">'./importModule'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// （5）在使用默认输出的情况下 如果模块输出一个函数 函数名的首字母应该小写 输出对象 对象名应该大写</span></span><br></pre></td></tr></table></figure>
<h3 id="ESLint的使用"><a class="header-anchor" href="#ESLint的使用">¶</a>ESLint的使用</h3>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 一个语法规则和代码风格的检查工具 可以用来保证写出语法正确 风格统一的代码</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// （1）安装</span></span><br><span class="line">npm i -g eslint</span><br><span class="line"></span><br><span class="line"><span class="comment">// （2）安装Airbnb语法规则 以及import ally react插件</span></span><br><span class="line">npm i -g eslint-config-airbnb </span><br><span class="line">npm i -g eslint-plugin-<span class="keyword">import</span> eslint-plugin-jsx-a11y eslint-plugin-react</span><br><span class="line"></span><br><span class="line"><span class="comment">// （3）在项目的根目录下新建一个 .eslintrc 文件 配置ESLint</span></span><br><span class="line">&#123; </span><br><span class="line">    <span class="string">"extends"</span>: <span class="string">"eslint-config-airbnb"</span> </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// （4）当写代码时 会自动检查（像平时一样 但是规范不同）</span></span><br></pre></td></tr></table></figure>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article id="post-18、Module" class="h-entry post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time class="dt-published" datetime="2020-07-23T14:10:40.000Z"><a href="/2020/07/23/18、Module/">2020-07-23</a></time>
      
      
  
    <h1 class="title"><a href="/2020/07/23/18、Module/">18、Module</a></h1>
  

    </header>
    <div class="e-content entry" itemprop="articleBody">
      
        <p>[TOC]</p>
<h2 id="Module"><a class="header-anchor" href="#Module">¶</a>Module</h2>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// commonJS模块就是对象 输入时必须查找对象属性</span></span><br><span class="line"><span class="keyword">let</span> fs=<span class="built_in">require</span>(<span class="string">'fs'</span>)</span><br><span class="line"><span class="comment">// es6模块（自动使用严格模式） 通过export命令显示指定输出的代码 通过import命令引入</span></span><br></pre></td></tr></table></figure>
<h3 id="export命令"><a class="header-anchor" href="#export命令">¶</a>export命令</h3>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// （1）一个模块就是一个独立的文件 该文件内部的所有变量 外部无法获取  如果想获取模块内的某个变量 就必须使用export输出该变量</span></span><br><span class="line"><span class="comment">// 方法一</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">var</span> 变量=值</span><br><span class="line"><span class="comment">// 方法二  优先考虑</span></span><br><span class="line"><span class="keyword">var</span> 变量<span class="number">1</span>=值<span class="number">1</span></span><br><span class="line"><span class="keyword">var</span> 变量<span class="number">2</span>=值<span class="number">2</span></span><br><span class="line"><span class="keyword">var</span> 变量<span class="number">3</span>=值<span class="number">3</span></span><br><span class="line"><span class="keyword">export</span> &#123;变量<span class="number">1</span>,变量<span class="number">2</span>,变量<span class="number">3</span>&#125;</span><br><span class="line"><span class="comment">// 输出函数或类</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> 函数名(<span class="params">参数</span>)</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// （2）重命名</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">v1</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">v2</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line"><span class="keyword">export</span>&#123;</span><br><span class="line">	v1 <span class="keyword">as</span> streamV1,</span><br><span class="line">    v2 <span class="keyword">as</span> streamV2,</span><br><span class="line">    v2 <span class="keyword">as</span> streamLatestVersion</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 使用as关键字 重命名函数v1和v2的对外接口  v2可以使用不同的名字输出两次</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// （3）export命令规定的是对外的接口 必须与模块内部的变量建立一一对应关系</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 错误写法</span></span><br><span class="line"><span class="keyword">export</span> <span class="number">1</span> <span class="comment">// 报错</span></span><br><span class="line"><span class="keyword">var</span> m=<span class="number">1</span></span><br><span class="line"><span class="keyword">export</span> m <span class="comment">// 报错</span></span><br><span class="line"><span class="comment">// 正确写法</span></span><br><span class="line"><span class="comment">// 写法一 </span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">var</span> m = <span class="number">1</span>; </span><br><span class="line"><span class="comment">// 写法二 </span></span><br><span class="line"><span class="keyword">var</span> m = <span class="number">1</span>; </span><br><span class="line"><span class="keyword">export</span> &#123;m&#125;; </span><br><span class="line"><span class="comment">// 写法三 </span></span><br><span class="line"><span class="keyword">var</span> n = <span class="number">1</span>; </span><br><span class="line"><span class="keyword">export</span> &#123;n <span class="keyword">as</span> m&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数 类</span></span><br><span class="line"><span class="comment">// 报错 </span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;&#125; <span class="keyword">export</span> f; </span><br><span class="line"><span class="comment">// 正确 </span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;&#125;; </span><br><span class="line"><span class="comment">// 正确 </span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;&#125; </span><br><span class="line"><span class="keyword">export</span> &#123;f&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// （4）export语句输出的接口 与其对应的值是动态绑定关系 即通过该接口 可以获取到模块内部实时的值</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">var</span> foo = <span class="string">'bar'</span>;</span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> foo = <span class="string">'baz'</span>, <span class="number">500</span>)</span><br><span class="line"><span class="comment">// 在500毫秒后 foo的值会变成baz</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// （5）export命令可以出现在模块任意位置（只有处于模块顶层就可以） 如果在块级作用域 会报错</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">    <span class="keyword">export</span> <span class="keyword">default</span> <span class="string">'bar'</span> <span class="comment">// SyntaxError </span></span><br><span class="line">&#125;</span><br><span class="line">foo()</span><br></pre></td></tr></table></figure>
<h3 id="import命令"><a class="header-anchor" href="#import命令">¶</a>import命令</h3>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// （1）import后面的变量名必须与export输出的变量名相同（顺序可以不同） 与对象的解构赋值有点像</span></span><br><span class="line"><span class="keyword">import</span> &#123;变量<span class="number">1</span>,变量<span class="number">2</span>,变量<span class="number">3</span>&#125; <span class="keyword">from</span> <span class="string">'绝对路径或相对路径'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// （2）重命名  </span></span><br><span class="line"><span class="keyword">import</span> &#123; lastName <span class="keyword">as</span> surname &#125; <span class="keyword">from</span> <span class="string">'./profile'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// （3）如果是模块名 不带有路径  必须要有配置文件（说明模块的位置）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// （4）import命令具有提升效果 会提升到整个模块的头部 首先执行</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// （5）import是静态执行的 不能使用表达式和变量</span></span><br><span class="line"><span class="comment">// 报错 </span></span><br><span class="line"><span class="keyword">import</span> &#123; <span class="string">'f'</span> + <span class="string">'oo'</span> &#125; <span class="keyword">from</span> <span class="string">'my_module'</span>; </span><br><span class="line"><span class="comment">// 报错 </span></span><br><span class="line"><span class="keyword">let</span> <span class="built_in">module</span> = <span class="string">'my_module'</span>; </span><br><span class="line"><span class="keyword">import</span> &#123; foo &#125; <span class="keyword">from</span> <span class="built_in">module</span>; </span><br><span class="line"><span class="comment">// 报错 </span></span><br><span class="line"><span class="keyword">if</span> (x === <span class="number">1</span>) &#123; </span><br><span class="line">    <span class="keyword">import</span> &#123; foo &#125; <span class="keyword">from</span> <span class="string">'module1'</span>; </span><br><span class="line">&#125; <span class="keyword">else</span> &#123; </span><br><span class="line">    <span class="keyword">import</span> &#123; foo &#125; <span class="keyword">from</span> <span class="string">'module2'</span>; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// （6）import语句会执行所加载的模块 可以有下面的写法</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">'lodash'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// （7）如果多次重复执行同一句import语句 只会执行一次</span></span><br><span class="line"><span class="keyword">import</span> &#123; foo &#125; <span class="keyword">from</span> <span class="string">'my_module'</span>; </span><br><span class="line"><span class="keyword">import</span> &#123; bar &#125; <span class="keyword">from</span> <span class="string">'my_module'</span>; </span><br><span class="line"><span class="comment">// 等同于 </span></span><br><span class="line"><span class="keyword">import</span> &#123;foo,bar&#125; <span class="keyword">from</span> <span class="string">'my_module'</span></span><br></pre></td></tr></table></figure>
<h4 id="模块的整体加载"><a class="header-anchor" href="#模块的整体加载">¶</a>模块的整体加载</h4>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// （1）除了加载某个输出值 还可以使用整体加载 即用*指定一个对象 所有的输出值都加载到这个对象上面</span></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> 对象名 <span class="keyword">from</span> <span class="string">'路径'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// （2）不允许运行时改变</span></span><br><span class="line">对象.变量 = <span class="string">'hello'</span>; </span><br><span class="line">对象.方法 = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="export-default命令"><a class="header-anchor" href="#export-default命令">¶</a>export default命令</h3>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// （1）在不知道变量名或函数名时 加载模块  一个模块只能有一个默认输出</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">import</span> 自定义的变量或函数名 <span class="keyword">from</span> <span class="string">'路径'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// （2）export default命令也可以用在非匿名函数前</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> 函数名(<span class="params"></span>)</span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 或</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> 函数名(<span class="params"></span>)</span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> 函数名</span><br><span class="line"></span><br><span class="line"><span class="comment">// （3）本质上 export default就是输出一个叫做default的变量或方法</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">x, y</span>) </span>&#123; </span><br><span class="line">    <span class="keyword">return</span> x * y; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> &#123;add <span class="keyword">as</span> <span class="keyword">default</span>&#125;; </span><br><span class="line"><span class="comment">// 等同于  </span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> add;  </span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123; <span class="keyword">default</span> <span class="keyword">as</span> foo &#125; <span class="keyword">from</span> <span class="string">'modules'</span>; </span><br><span class="line"><span class="comment">// 等同于 </span></span><br><span class="line"><span class="keyword">import</span> foo <span class="keyword">from</span> <span class="string">'modules'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确 </span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">var</span> a = <span class="number">1</span>; </span><br><span class="line"><span class="comment">// 正确 </span></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>; </span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> a; </span><br><span class="line"><span class="comment">// 正确 </span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="number">42</span></span><br><span class="line"><span class="comment">// 错误 </span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">var</span> a = <span class="number">1</span>; </span><br><span class="line"></span><br><span class="line"><span class="comment">// （4）在一条import语句中 同时输入默认方法和其他接口</span></span><br><span class="line"><span class="keyword">import</span> 自定义的变量名或函数名 , &#123; each, each <span class="keyword">as</span> forEach &#125; <span class="keyword">from</span> <span class="string">'lodash'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// export * 命令会忽略引入模块的default方法//</span></span><br></pre></td></tr></table></figure>
<h3 id="export与import的复合写法"><a class="header-anchor" href="#export与import的复合写法">¶</a>export与import的复合写法</h3>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> &#123; foo, bar &#125; <span class="keyword">from</span> <span class="string">'my_module'</span>; </span><br><span class="line"><span class="comment">// 等同于 </span></span><br><span class="line"><span class="keyword">import</span> &#123; foo, bar &#125; <span class="keyword">from</span> <span class="string">'my_module'</span>; </span><br><span class="line"><span class="keyword">export</span> &#123; foo, bar &#125;; </span><br><span class="line"></span><br><span class="line"><span class="comment">// （1）接口重命名</span></span><br><span class="line"><span class="keyword">export</span> &#123;foo <span class="keyword">as</span> myFoo&#125; <span class="keyword">from</span> <span class="string">'路径'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// （2）整体输出</span></span><br><span class="line"><span class="keyword">export</span> * <span class="keyword">from</span> <span class="string">'路径'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// （3）默认接口</span></span><br><span class="line"><span class="keyword">export</span> &#123;<span class="keyword">default</span>&#125; <span class="keyword">from</span> <span class="string">'路径'</span></span><br><span class="line"><span class="keyword">export</span> &#123;变量名 <span class="keyword">as</span> <span class="keyword">default</span>&#125; <span class="keyword">from</span> <span class="string">'路径'</span></span><br><span class="line"><span class="keyword">export</span> &#123;<span class="keyword">default</span> <span class="keyword">as</span> 变量名&#125; <span class="keyword">from</span> <span class="string">'路径'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// （4）其他形式</span></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> someIdentifier <span class="keyword">from</span> <span class="string">"someModule"</span>; </span><br><span class="line"><span class="keyword">import</span> someIdentifier <span class="keyword">from</span> <span class="string">"someModule"</span>; </span><br><span class="line"><span class="keyword">import</span> someIdentifier, &#123; namedIdentifier &#125; <span class="keyword">from</span> <span class="string">"someModule"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 复合写法</span></span><br><span class="line"><span class="keyword">export</span> * <span class="keyword">as</span> someIdentifier <span class="keyword">from</span> <span class="string">"someModule"</span>; </span><br><span class="line"><span class="keyword">export</span> someIdentifier <span class="keyword">from</span> <span class="string">"someModule"</span>; </span><br><span class="line"><span class="keyword">export</span> someIdentifier, &#123; namedIdentifier &#125; <span class="keyword">from</span> <span class="string">"someModule"</span></span><br></pre></td></tr></table></figure>
<h3 id="跨模块常量"><a class="header-anchor" href="#跨模块常量">¶</a>跨模块常量</h3>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// const 声明的常量只在当前代码块有效  如果一个常量要被多个模块共享 采用下面写法</span></span><br><span class="line"><span class="comment">// 模块1</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> 常量=<span class="number">1</span></span><br><span class="line"><span class="comment">// 模块2</span></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> 模块<span class="number">1</span> <span class="keyword">from</span> <span class="string">'路径'</span></span><br><span class="line"><span class="built_in">console</span>.log(模块<span class="number">1.</span>常量) <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>
<h3 id="import"><a class="header-anchor" href="#import">¶</a>import()</h3>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// import()可以像require一样进行动态加载 import()是异步加载  require是同步加载</span></span><br><span class="line"><span class="comment">// import() 返回一个promise对象  import()加载模块成功以后 这个模块会作为一个对象 当作then方法的参数</span></span><br><span class="line"><span class="keyword">import</span>(<span class="string">'./myModule.js'</span>).then(<span class="function"><span class="keyword">function</span>(<span class="params">模块</span>)</span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;); </span><br><span class="line"><span class="comment">// 同时加载多个模块 可以采用Promise.all</span></span><br><span class="line"><span class="built_in">Promise</span>.all([ </span><br><span class="line">    <span class="keyword">import</span>(<span class="string">'./module1.js'</span>), </span><br><span class="line">    <span class="keyword">import</span>(<span class="string">'./module2.js'</span>), </span><br><span class="line">    <span class="keyword">import</span>(<span class="string">'./module3.js'</span>), </span><br><span class="line">]).then(<span class="function">(<span class="params">[module1, module2, module3]</span>) =&gt;</span> &#123; </span><br><span class="line">    ··· </span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//也可以用在async函数中</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">main</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">    <span class="keyword">const</span> myModule = <span class="keyword">await</span> <span class="keyword">import</span>(<span class="string">'./myModule.js'</span>); </span><br><span class="line">    <span class="keyword">const</span> &#123;export1, export2&#125; = <span class="keyword">await</span> <span class="keyword">import</span>(<span class="string">'./myModule.js'</span>); </span><br><span class="line">    <span class="keyword">const</span> [module1, module2, module3] = <span class="keyword">await</span> <span class="built_in">Promise</span>.all([ </span><br><span class="line">        <span class="keyword">import</span>(<span class="string">'./module1.js'</span>), </span><br><span class="line">        <span class="keyword">import</span>(<span class="string">'./module2.js'</span>), </span><br><span class="line">        <span class="keyword">import</span>(<span class="string">'./module3.js'</span>), </span><br><span class="line">    ]); </span><br><span class="line">&#125;</span><br><span class="line">main()</span><br></pre></td></tr></table></figure>
<h3 id="浏览器加载"><a class="header-anchor" href="#浏览器加载">¶</a>浏览器加载</h3>
<h4 id="传统方法"><a class="header-anchor" href="#传统方法">¶</a>传统方法</h4>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 浏览器通过&lt;script&gt;标签加载JavaScript脚本 --&gt;</span> </span><br><span class="line"><span class="comment">&lt;!-- 页面内嵌入脚本 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"application/javascript"</span>&gt;</span> </span><br><span class="line"><span class="actionscript">    <span class="comment">// module code </span></span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span> </span><br><span class="line"><span class="comment">&lt;!-- 外部脚本 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"application/javascript"</span> <span class="attr">src</span>=<span class="string">"path/to/myModule.js"</span>&gt;</span></span><br><span class="line"><span class="actionscript">	<span class="comment">// code</span></span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 默认情况下浏览器同步加载JavaScript脚本（即渲染引擎遇 到 &lt;script&gt; 标签就会停下来，等到执行完脚本，再继续向下渲染） --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 异步加载 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"path/to/myModule.js"</span> <span class="attr">defer</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"path/to/myModule.js"</span> <span class="attr">async</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h5 id="加载规则"><a class="header-anchor" href="#加载规则">¶</a>加载规则</h5>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 浏览器加载es6模块 对于带有type='module'的脚本 都会异步加载 等到页面渲染完 再执行模块脚本 如果有多个按照出现顺序执行 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"module"</span> <span class="attr">src</span>=<span class="string">"./foo.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- es6模块也可以内嵌在网页中 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"module"</span>&gt;</span> </span><br><span class="line"><span class="actionscript">    <span class="comment">// 引入模块 </span></span></span><br><span class="line"><span class="actionscript">    <span class="comment">// other code </span></span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span> </span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 对于外部的模块脚本 代码是在模块作用域之中运行，而不是在全局作用域运行 模块内部的顶层变量，外部不可见 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 模块脚本自动采用严格模式 不管有没有声明 use strict --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 模块之中，可以使用 import 命令加载其他模块（.js 后缀不可省略，需要提供绝对 URL 或相对 URL） 也可以使用 export 命令 输出对外接口。 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 模块之中，顶层的 this 关键字返回 undefined ，而不是指向 window 。也就是说，在模块顶层使用 this 关键字，是无意义的。 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 同一个模块如果加载多次，将只执行一次 --&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="es6模块与CommonJS模块的差异"><a class="header-anchor" href="#es6模块与CommonJS模块的差异">¶</a>es6模块与CommonJS模块的差异</h3>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// CommonJS模块输出的是一个值的拷贝  es6模块输出的是值得引用</span></span><br><span class="line"><span class="comment">// CommonJS模块是运行时加载  es6模块是编译时输出接口</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// lib.js </span></span><br><span class="line"><span class="keyword">var</span> counter = <span class="number">3</span>; </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">incCounter</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">    counter++; </span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">module</span>.exports = &#123; </span><br><span class="line">    counter: counter, </span><br><span class="line">    incCounter: incCounter </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// main.js </span></span><br><span class="line"><span class="keyword">var</span> mod = <span class="built_in">require</span>(<span class="string">'./lib'</span>); </span><br><span class="line"><span class="built_in">console</span>.log(mod.counter); <span class="comment">// 3 </span></span><br><span class="line">mod.incCounter(); </span><br><span class="line"><span class="built_in">console</span>.log(mod.counter); <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>
<h3 id=""><a class="header-anchor" href="#">¶</a></h3>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article id="post-3、字符串的扩展" class="h-entry post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time class="dt-published" datetime="2020-07-22T13:14:15.000Z"><a href="/2020/07/22/3、字符串的扩展/">2020-07-22</a></time>
      
      
  
    <h1 class="title"><a href="/2020/07/22/3、字符串的扩展/">3、字符串的扩展</a></h1>
  

    </header>
    <div class="e-content entry" itemprop="articleBody">
      
        <p>[TOC]</p>
<h2 id="字符串扩展"><a class="header-anchor" href="#字符串扩展">¶</a>字符串扩展</h2>
<h3 id="字符的unicode表示法"><a class="header-anchor" href="#字符的unicode表示法">¶</a>字符的unicode表示法</h3>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// js采用 \uxxxx 的形式表示一个字符  xxxx 表示字符的码点（仅限于\u0000 ~ \uFFFF 之间的字符） </span></span><br><span class="line"><span class="string">"\u0061"</span> <span class="comment">// "a"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//  超出范围的字符必须使用双字节的形式表示</span></span><br><span class="line"><span class="string">"\uD842\uDFB7"</span> <span class="comment">// ""</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果直接在 \u 后跟超过 FFFF 的数值  \u20BB7 会被理解为 \u20BB+7</span></span><br><span class="line"><span class="string">"\u20BB7"</span> <span class="comment">// " 7"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 在es6中 使用 \u&#123;xxxxx&#125; 可以正确识别</span></span><br><span class="line"><span class="string">"\u&#123;20BB7&#125;"</span> <span class="comment">// "" </span></span><br><span class="line"><span class="string">"\u&#123;41&#125;\u&#123;42&#125;\u&#123;43&#125;"</span> <span class="comment">// "ABC"</span></span><br></pre></td></tr></table></figure>
<h3 id="方法"><a class="header-anchor" href="#方法">¶</a>方法</h3>
<h4 id="处理四个字节储存的字符-码点大于FFFF的字符-返回一个字符的码点-10进制"><a class="header-anchor" href="#处理四个字节储存的字符-码点大于FFFF的字符-返回一个字符的码点-10进制">¶</a>处理四个字节储存的字符(码点大于FFFF的字符) 返回一个字符的码点(10进制)</h4>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// （1）字符串.codePointAt(索引)  在遇到码点大于FFFF字符时 会占据两个位置</span></span><br><span class="line"><span class="comment">// （2）该方法读取第一个位置码点为字符的正确码点 第二个位置为字符后两位的码点</span></span><br><span class="line"><span class="keyword">var</span> s = <span class="string">'𠮷a'</span>;</span><br><span class="line">s.codePointAt(<span class="number">0</span>) <span class="comment">// 134071 𠮷 占据两个位置 现在读取到 𠮷 的正确码点</span></span><br><span class="line">s.codePointAt(<span class="number">1</span>) <span class="comment">// 57271  读取到 𠮷 的后 两位的码点</span></span><br><span class="line">s.codePointAt(<span class="number">2</span>) <span class="comment">// 97  读取到 a 的码点</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// （3）如果需要16进制的码点 可以使用 toString 来转换</span></span><br><span class="line"><span class="keyword">var</span> s = <span class="string">'𠮷a'</span>;</span><br><span class="line">s.codePointAt(<span class="number">0</span>).toString(<span class="number">16</span>) <span class="comment">// "20bb7"</span></span><br><span class="line">s.codePointAt(<span class="number">2</span>).toString(<span class="number">16</span>) <span class="comment">// "61"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// （4）解决方法 使用for...of循环</span></span><br><span class="line"><span class="keyword">var</span> s = <span class="string">'𠮷a'</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> ch <span class="keyword">of</span> s) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(ch.codePointAt(<span class="number">0</span>).toString(<span class="number">16</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 20bb7</span></span><br><span class="line"><span class="comment">// 61</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// （5）该方法时测试一个字符是两个字节还是四个字节的最简单方法</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">is32Bit</span>(<span class="params">c</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> c.codePointAt(<span class="number">0</span>) &gt; <span class="number">0xFFFF</span>;</span><br><span class="line">&#125;</span><br><span class="line">is32Bit(<span class="string">"𠮷"</span>) <span class="comment">// true</span></span><br><span class="line">is32Bit(<span class="string">"a"</span>) <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// （6）charCodeAt 使用方法与上述相同  但是 读取的是前两位和后两位的码点</span></span><br><span class="line"><span class="keyword">var</span> s = <span class="string">'𠮷'</span> </span><br><span class="line">s.charCodeAt(<span class="number">0</span>) <span class="comment">// 55362 前两位</span></span><br><span class="line">s.charCodeAt(<span class="number">1</span>) <span class="comment">// 57271 后两位</span></span><br></pre></td></tr></table></figure>
<h4 id="传入码点-返回字符"><a class="header-anchor" href="#传入码点-返回字符">¶</a>传入码点 返回字符</h4>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// （1）es5  String.fromChatCode(0x码点) 如果大于FFFF 会舍弃最前面的数字</span></span><br><span class="line"><span class="built_in">String</span>.fromChatCode(<span class="number">0x61</span>) <span class="comment">// a</span></span><br><span class="line"><span class="built_in">String</span>.fromCharCode(<span class="number">0x20BB7</span>) <span class="comment">// "ஷ" 舍弃了2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// （2）String.fromCodePoint(0x码点)  可以识别大于FFFF的字符 可以接收多个参数 会被合并成一个字符串返回</span></span><br><span class="line"><span class="built_in">String</span>.fromCodePoint(<span class="number">0x20BB7</span>)</span><br><span class="line"><span class="comment">// "𠮷"</span></span><br><span class="line"><span class="built_in">String</span>.fromCodePoint(<span class="number">0x78</span>, <span class="number">0x1f680</span>, <span class="number">0x79</span>) === <span class="string">'x\uD83D\uDE80y'</span> </span><br><span class="line"><span class="comment">// 'x\uD83D\uDE80y' = 'x'+'\uD83D\uDE80'+'y'</span></span><br><span class="line"><span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<h4 id="返回字符串给定位置的字符"><a class="header-anchor" href="#返回字符串给定位置的字符">¶</a>返回字符串给定位置的字符</h4>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// es5 字符串.charAt(索引) 不能识别大于FFFF的字符</span></span><br><span class="line"><span class="string">'abc'</span>.charAt(<span class="number">0</span>) <span class="comment">// "a"</span></span><br><span class="line"><span class="string">'𠮷'</span>.charAt(<span class="number">0</span>) <span class="comment">// "\uD842"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 字符串.at(索引) （通过垫片库实现）</span></span><br><span class="line"><span class="string">'abc'</span>.at(<span class="number">0</span>) <span class="comment">// "a"</span></span><br><span class="line"><span class="string">'𠮷'</span>.at(<span class="number">0</span>) <span class="comment">// "𠮷"</span></span><br></pre></td></tr></table></figure>
<h3 id="字符串的遍历接口"><a class="header-anchor" href="#字符串的遍历接口">¶</a>字符串的遍历接口</h3>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 可以识别大于FFFF的码点</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> codePoint <span class="keyword">of</span> <span class="string">'foo'</span>) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(codePoint)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// "f"</span></span><br><span class="line"><span class="comment">// "o"</span></span><br><span class="line"><span class="comment">// "o"</span></span><br></pre></td></tr></table></figure>
<h4 id="将字符的不同表示方式统一为同样的形式"><a class="header-anchor" href="#将字符的不同表示方式统一为同样的形式">¶</a>将字符的不同表示方式统一为同样的形式</h4>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 字符串.normalize(参数)  只能识别两个字符合成（三个或三个以上不行）</span></span><br><span class="line"><span class="comment">// NFC（视觉和语义上的等价） 默认参数 返回多个简单字符合成的合成字符</span></span><br><span class="line"><span class="comment">// NFD 在NFC的前提下 返回合成字符分解的多个简单字符</span></span><br><span class="line"><span class="comment">// NFKC（在语义上等价 在视觉上不等价）返回合成字符</span></span><br><span class="line"><span class="comment">// NFKD 在NFKC的前提下 返回合成字符分解的多个简单字符</span></span><br><span class="line"><span class="string">'\u01D1'</span>.normalize() === <span class="string">'\u004F\u030C'</span>.normalize() <span class="comment">// true</span></span><br><span class="line"><span class="string">'\u004F\u030C'</span>.normalize(<span class="string">'NFC'</span>).length <span class="comment">// 1</span></span><br><span class="line"><span class="string">'\u004F\u030C'</span>.normalize(<span class="string">'NFD'</span>).length <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>
<h4 id="确定一个字符串是否包含在另一个字符串中"><a class="header-anchor" href="#确定一个字符串是否包含在另一个字符串中">¶</a>确定一个字符串是否包含在另一个字符串中</h4>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 字符串.startsWith(字符串,n) 在该字符串的第n个字符到字符串结束中查找参数字符串</span></span><br><span class="line"><span class="comment">// 字符串.endsWith(字符串,n)  在该字符串的前n个字符中查找参数字符串</span></span><br><span class="line"><span class="comment">// 字符串.includes(字符串,n)  在该字符串的第n个字符到字符串结束中查找参数字符串</span></span><br><span class="line"><span class="comment">// 均返回bool</span></span><br><span class="line"><span class="keyword">var</span> s = <span class="string">'Hello world!'</span>;</span><br><span class="line"></span><br><span class="line">s.startsWith(<span class="string">'world'</span>, <span class="number">6</span>) <span class="comment">// true</span></span><br><span class="line">s.endsWith(<span class="string">'Hello'</span>, <span class="number">5</span>) <span class="comment">// true</span></span><br><span class="line">s.includes(<span class="string">'Hello'</span>, <span class="number">6</span>) <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<h4 id="将字符重复n次-返回"><a class="header-anchor" href="#将字符重复n次-返回">¶</a>将字符重复n次 返回</h4>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 字符串.repeat(n)  将字符串重复n次 再返回 </span></span><br><span class="line"><span class="comment">// 如果参数是小数 向下取整 负数或Infinity报错 0到-1之间的小数，则等同于0  参数NaN等同于0 如果repeat的参数是字符串，则会先转换成数字</span></span><br><span class="line"><span class="string">'x'</span>.repeat(<span class="number">3</span>) <span class="comment">// "xxx"</span></span><br><span class="line"><span class="string">'hello'</span>.repeat(<span class="number">2</span>) <span class="comment">// "hellohello"</span></span><br><span class="line"><span class="string">'na'</span>.repeat(<span class="number">0</span>) <span class="comment">// ""</span></span><br></pre></td></tr></table></figure>
<h4 id="补全字符串"><a class="header-anchor" href="#补全字符串">¶</a>补全字符串</h4>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 字符串.padStart(字符串的最小长度,字符串) 在头部补全</span></span><br><span class="line"><span class="comment">// 字符串.padEnd(字符串的最小长度,字符串) 在尾部补全</span></span><br><span class="line"><span class="string">'x'</span>.padStart(<span class="number">5</span>, <span class="string">'ab'</span>) <span class="comment">// 'ababx'</span></span><br><span class="line"><span class="string">'x'</span>.padStart(<span class="number">4</span>, <span class="string">'ab'</span>) <span class="comment">// 'abax'</span></span><br><span class="line"></span><br><span class="line"><span class="string">'x'</span>.padEnd(<span class="number">5</span>, <span class="string">'ab'</span>) <span class="comment">// 'xabab'</span></span><br><span class="line"><span class="string">'x'</span>.padEnd(<span class="number">4</span>, <span class="string">'ab'</span>) <span class="comment">// 'xaba'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// （1）如果用来补全的字符串与原字符串，两者的长度之和超过了指定的最小长度，则会截去超出位数的补全字符串</span></span><br><span class="line"><span class="string">'abc'</span>.padStart(<span class="number">10</span>, <span class="string">'0123456789'</span>)</span><br><span class="line"><span class="comment">// '0123456abc'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// （2）如果省略第二个参数 会用空格补全</span></span><br><span class="line"><span class="string">'x'</span>.padStart(<span class="number">4</span>) <span class="comment">// '   x'</span></span><br><span class="line"><span class="string">'x'</span>.padEnd(<span class="number">4</span>) <span class="comment">// 'x   '</span></span><br></pre></td></tr></table></figure>
<h4 id="转义字符串"><a class="header-anchor" href="#转义字符串">¶</a>转义字符串</h4>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// String.raw`` 将字符串转义</span></span><br><span class="line"><span class="comment">// （1）转义反斜杠</span></span><br><span class="line"><span class="built_in">String</span>.raw<span class="string">`Hi\u000A!`</span>;</span><br><span class="line"><span class="comment">// 'Hi\\u000A!'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// （2）转义变量</span></span><br><span class="line"><span class="built_in">String</span>.raw<span class="string">`Hi\n<span class="subst">$&#123;<span class="number">2</span>+<span class="number">3</span>&#125;</span>!`</span>;</span><br><span class="line"><span class="comment">// "Hi\\n5!"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// （3）基本代码</span></span><br><span class="line"><span class="built_in">String</span>.raw = <span class="function"><span class="keyword">function</span> (<span class="params">strings, ...values</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> output = <span class="string">""</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> index = <span class="number">0</span>; index &lt; values.length; index++) &#123;</span><br><span class="line">    output += strings.raw[index] + values[index];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  output += strings.raw[index]</span><br><span class="line">  <span class="keyword">return</span> output;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="模板字符串"><a class="header-anchor" href="#模板字符串">¶</a>模板字符串</h3>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 普通字符串</span></span><br><span class="line"><span class="string">`In JavaScript '\n' is a line-feed.`</span> <span class="comment">// 换行</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 多行字符串</span></span><br><span class="line"><span class="string">`In JavaScript this is</span></span><br><span class="line"><span class="string"> not legal.`</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 嵌入变量 也可以进行运算 或调用函数 如果&#123;&#125;中不是字符串会按照一般规则转为字符串 如果&#123;&#125;中变量没有声明 会报错</span></span><br><span class="line"><span class="string">`字符<span class="subst">$&#123;变量&#125;</span>字符`</span> <span class="comment">// `Hello $&#123;name&#125;, how are you $&#123;time&#125;?`</span></span><br><span class="line"><span class="string">`字符<span class="subst">$&#123;变量+变量&#125;</span>字符`</span> </span><br><span class="line"><span class="string">`字符<span class="subst">$&#123;函数(参数)&#125;</span>字符`</span> </span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果需要在模板字符串中使用反引号 需加\转义</span></span><br><span class="line"><span class="keyword">var</span> greeting = <span class="string">`\`Yo\` World!`</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 所有模板字符串的空格和换行都会被保留</span></span><br><span class="line"><span class="string">`</span></span><br><span class="line"><span class="string">&lt;ul&gt;</span></span><br><span class="line"><span class="string">  &lt;li&gt;first&lt;/li&gt;</span></span><br><span class="line"><span class="string">  &lt;li&gt;second&lt;/li&gt;</span></span><br><span class="line"><span class="string">&lt;/ul&gt;</span></span><br><span class="line"><span class="string">`</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 模板字符串还可以嵌套</span></span><br><span class="line"><span class="string">`</span></span><br><span class="line"><span class="string">  &lt;table&gt;</span></span><br><span class="line"><span class="string">  <span class="subst">$&#123;addrs.map(addr =&gt; <span class="string">`</span></span></span></span><br><span class="line"><span class="string"><span class="subst"><span class="string">    &lt;tr&gt;&lt;td&gt;<span class="subst">$&#123;addr.first&#125;</span>&lt;/td&gt;&lt;/tr&gt;</span></span></span></span><br><span class="line"><span class="string"><span class="subst"><span class="string">    &lt;tr&gt;&lt;td&gt;<span class="subst">$&#123;addr.last&#125;</span>&lt;/td&gt;&lt;/tr&gt;</span></span></span></span><br><span class="line"><span class="string"><span class="subst"><span class="string">  `</span>).join(<span class="string">''</span>)&#125;</span></span></span><br><span class="line"><span class="string">  &lt;/table&gt;</span></span><br><span class="line"><span class="string">`</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 引用模板字符串 在需要时执行</span></span><br><span class="line"><span class="comment">// 写法一</span></span><br><span class="line"><span class="keyword">let</span> str = <span class="string">'return '</span> + <span class="string">'`Hello $&#123;name&#125;!`'</span>;</span><br><span class="line"><span class="keyword">let</span> func = <span class="keyword">new</span> <span class="built_in">Function</span>(<span class="string">'name'</span>, str);</span><br><span class="line">func(<span class="string">'Jack'</span>) <span class="comment">// "Hello Jack!"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 写法二</span></span><br><span class="line"><span class="keyword">let</span> str = <span class="string">'(name) =&gt; `Hello $&#123;name&#125;!`'</span>;</span><br><span class="line"><span class="keyword">let</span> func = <span class="built_in">eval</span>.call(<span class="literal">null</span>, str);</span><br><span class="line">func(<span class="string">'Jack'</span>) <span class="comment">// "Hello Jack!"</span></span><br></pre></td></tr></table></figure>
<h3 id="标签模板"><a class="header-anchor" href="#标签模板">¶</a>标签模板</h3>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 就是函数调用的特殊形式</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// （1）简单调用</span></span><br><span class="line">alert<span class="string">`123`</span></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line">alert(<span class="number">123</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// （2）带有更多的参数</span></span><br><span class="line">函数<span class="string">`字符串1<span class="subst">$&#123;变量运算<span class="number">1</span>&#125;</span>字符串2<span class="subst">$&#123;变量运算<span class="number">2</span>&#125;</span>`</span></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line">函数([字符串<span class="number">1</span>,字符串<span class="number">2</span>,<span class="string">''</span>],变量运算结果<span class="number">1</span>,变量运算结果<span class="number">2</span>)</span><br><span class="line"><span class="comment">// 公式 将$&#123;&#125;两边的字符串组成一个数组作为第一个参数（若$&#123;&#125;放在最后 ''为数值的最后一个元素） 将第一个$&#123;&#125;里面的结果作为第二个参数 一次类推</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// （3）将字符串拼回去</span></span><br><span class="line"><span class="comment">// arguments写法</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> 函数(<span class="params">literals</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> result = <span class="string">''</span>;</span><br><span class="line">  <span class="keyword">var</span> i = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> (i &lt; literals.length) &#123;</span><br><span class="line">    result += literals[i++]; <span class="comment">// 注 i === i++</span></span><br><span class="line">    <span class="keyword">if</span> (i &lt; <span class="built_in">arguments</span>.length) &#123;</span><br><span class="line">      result += <span class="built_in">arguments</span>[i];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// rest参数写法（用这种）</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> 函数(<span class="params">literals, ...values</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> output = <span class="string">""</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> index = <span class="number">0</span>; index &lt; values.length; index++) &#123;</span><br><span class="line">    output += literals[index] + values[index];</span><br><span class="line">  &#125;</span><br><span class="line">  output += literals[index]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article id="post-12、promise对象" class="h-entry post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time class="dt-published" datetime="2020-07-22T02:52:41.000Z"><a href="/2020/07/22/12、promise对象/">2020-07-22</a></time>
      
      
  
    <h1 class="title"><a href="/2020/07/22/12、promise对象/">12、promise对象</a></h1>
  

    </header>
    <div class="e-content entry" itemprop="articleBody">
      
        <p>[TOC]</p>
<h2 id="promise对象"><a class="header-anchor" href="#promise对象">¶</a>promise对象</h2>
<ul>
<li>保存着某个未来才会结束的事件（通常是异步操作）的结果  从它可以获取异步操作的消息</li>
<li>promise对象状态不受外界影响（三种状态 pending进行中  fulfilled已成功  rejected已失败）</li>
<li>状态一旦改变  就不会再变  任何时候都可以得到这个结果</li>
<li>无法取消promise  一旦新建就会立即执行  如果不设置回调函数  错误不会反应到外部</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在promise对象中调用resolve函数会将状态变成成功  调用reject会将状态变成失败  不调用则一直是进行中</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> 函数名(<span class="params">参数</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve,reject</span>)</span>&#123;</span><br><span class="line">    	<span class="comment">// some code</span></span><br><span class="line">	&#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123; </span><br><span class="line">    <span class="comment">// ... some code </span></span><br><span class="line">    <span class="keyword">if</span> (<span class="comment">/* 异步操作成功 */</span>)&#123; </span><br><span class="line">        resolve(value); </span><br><span class="line">	&#125; <span class="keyword">else</span> &#123; </span><br><span class="line">     	reject(error); </span><br><span class="line">	&#125; </span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当在一个promise对象中使用另一个promise对象作为resolve或reject函数的参数</span></span><br><span class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        reject(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'fail'</span>))</span><br><span class="line">    &#125;, <span class="number">3000</span>)</span><br><span class="line">&#125;) </span><br><span class="line"><span class="keyword">var</span> p2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        resolve(p1)</span><br><span class="line">    &#125;, <span class="number">1000</span>)</span><br><span class="line">&#125;) </span><br><span class="line">p2.then(<span class="function"><span class="params">result</span> =&gt;</span> <span class="built_in">console</span>.log(result)).catch(<span class="function"><span class="params">error</span> =&gt;</span> <span class="built_in">console</span>.log(error))</span><br><span class="line"><span class="comment">// Error: fail</span></span><br><span class="line"><span class="comment">// 因为p2返回了p1 所以p2的状态由p1决定</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用resolve或reject函数并不会终结函数的执行  resolve和reject会在函数执行完成后再调用  最好在调用这两个函数是使用return   return resolve()</span></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    resolve(<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">2</span>);</span><br><span class="line">&#125;).then(<span class="function"><span class="params">r</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(r);</span><br><span class="line">&#125;); </span><br><span class="line"><span class="comment">// 2 </span></span><br><span class="line"><span class="comment">// 1</span></span><br></pre></td></tr></table></figure>
<h3 id="方法"><a class="header-anchor" href="#方法">¶</a>方法</h3>
<h4 id="then"><a class="header-anchor" href="#then">¶</a>then</h4>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">promise对象或函数(参数).then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// resolve函数</span></span><br><span class="line">&#125;,<span class="function"><span class="keyword">function</span>(<span class="params">error</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// reject函数</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 链式操作</span></span><br><span class="line">promise对象或函数(参数).then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// resolve函数</span></span><br><span class="line">    <span class="comment">// 返回一个promise对象</span></span><br><span class="line">&#125;,<span class="function"><span class="keyword">function</span>(<span class="params">error</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// reject函数</span></span><br><span class="line">    <span class="comment">// 返回一个promise对象</span></span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// resolve函数</span></span><br><span class="line">&#125;,<span class="function"><span class="keyword">function</span>(<span class="params">error</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// reject函数</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h4 id="catch"><a class="header-anchor" href="#catch">¶</a>catch</h4>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 对象.catch(reject) 相当于 对象.then(null,reject) </span></span><br><span class="line"><span class="comment">// 在链式操作的最后使用</span></span><br><span class="line"><span class="comment">// 捕捉错误   如果状态变成成功 不能抛出错误</span></span><br><span class="line"><span class="keyword">var</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'test'</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">        reject(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">promise.catch(<span class="function"><span class="keyword">function</span> (<span class="params">error</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(error);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// promise对象的错误具有冒泡性质 会一直向后传递  直到被捕获为止</span></span><br></pre></td></tr></table></figure>
<h4 id="all"><a class="header-anchor" href="#all">¶</a>all</h4>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p = <span class="built_in">Promise</span>.all([p1, p2, p3])</span><br><span class="line"><span class="comment">// 都是promise实例  如果不是会调用promise.resolve将数组中的元素转化为实例</span></span><br><span class="line"><span class="comment">// 参数可以不是数组 但必须有Iterator接口 且返回的每个成员都是promise实例</span></span><br><span class="line"><span class="comment">// 只有p1  p2  p3的状态都成功 p才会变成成功  三者返回值组成数组传递给resolve回调</span></span><br><span class="line"><span class="comment">// 如果有一个失败 则p失败  第一个被rejected的实例返回值传递给reject回调</span></span><br></pre></td></tr></table></figure>
<h4 id="race"><a class="header-anchor" href="#race">¶</a>race</h4>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p = <span class="built_in">Promise</span>.race([p1, p2, p3])</span><br><span class="line"><span class="comment">// 只要其中一个的状态改变 p跟着改变（无论是成功还是失败） 返回值传递给对应的回调</span></span><br></pre></td></tr></table></figure>
<h4 id="resolve"><a class="header-anchor" href="#resolve">¶</a>resolve</h4>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果参数是promise实例  原封不动地返回该实例</span></span><br><span class="line"><span class="comment">// 如果参数是具有then方法的对象  将该对象转为promise对象</span></span><br><span class="line"><span class="comment">// 不是对象或没有then方法的对象 返回一个promise对象 状态为resolve 像下面一样</span></span><br><span class="line"><span class="built_in">Promise</span>.resolve(参数)</span><br><span class="line"><span class="comment">// 等价于</span></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve</span>)</span>&#123;</span><br><span class="line">    resolve(参数)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 不带参数 同上但没有参数</span></span><br></pre></td></tr></table></figure>
<h4 id="reject"><a class="header-anchor" href="#reject">¶</a>reject</h4>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p = <span class="built_in">Promise</span>.reject(参数); </span><br><span class="line"><span class="comment">// 等同于 </span></span><br><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve,reject</span>)</span>&#123;</span><br><span class="line">    reject(参数)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 无论传递什么都是这样 原封不动传递给reject回调</span></span><br></pre></td></tr></table></figure>
<h4 id="done"><a class="header-anchor" href="#done">¶</a>done</h4>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 链式操作无论是以then方法还是catch方法结尾  最后一个方法抛出错误都有可能捕捉不到</span></span><br><span class="line"><span class="comment">// 定义一个done方法总处于尾端 保证抛出错误</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现</span></span><br><span class="line"><span class="built_in">Promise</span>.prototype.done = <span class="function"><span class="keyword">function</span> (<span class="params">onFulfilled, onRejected</span>) </span>&#123; </span><br><span class="line">    <span class="keyword">this</span>.then(onFulfilled, onRejected).catch(<span class="function"><span class="keyword">function</span> (<span class="params">reason</span>) </span>&#123; </span><br><span class="line">        <span class="comment">// 抛出一个全局错误 </span></span><br><span class="line">        setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123; <span class="keyword">throw</span> reason &#125;, <span class="number">0</span>); </span><br><span class="line">    &#125;); </span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 可以像普通方法一样提供回调函数  也可以不提供回调（一样可以抛出错误）</span></span><br></pre></td></tr></table></figure>
<h4 id="finally"><a class="header-anchor" href="#finally">¶</a>finally</h4>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 作为结尾  不管promise对象最后状态如何 都会执行的操作 接收一个普通回调函数作为参数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现</span></span><br><span class="line"><span class="built_in">Promise</span>.prototype.finally = <span class="function"><span class="keyword">function</span> (<span class="params">callback</span>) </span>&#123; </span><br><span class="line">    <span class="keyword">let</span> P = <span class="keyword">this</span>.constructor; </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.then( </span><br><span class="line">        value =&gt; P.resolve(callback()).then(<span class="function"><span class="params">()</span> =&gt;</span> value), </span><br><span class="line">        reason =&gt; P.resolve(callback()).then(<span class="function"><span class="params">()</span> =&gt;</span> &#123; </span><br><span class="line">            <span class="keyword">throw</span> reason </span><br><span class="line">        &#125;) </span><br><span class="line">    ); </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id=""><a class="header-anchor" href="#">¶</a></h4>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article id="post-15、async函数" class="h-entry post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time class="dt-published" datetime="2020-07-21T13:58:00.000Z"><a href="/2020/07/21/15、async函数/">2020-07-21</a></time>
      
      
  
    <h1 class="title"><a href="/2020/07/21/15、async函数/">async函数</a></h1>
  

    </header>
    <div class="e-content entry" itemprop="articleBody">
      
        <p>[TOC]</p>
<h2 id="async函数"><a class="header-anchor" href="#async函数">¶</a>async函数</h2>
<ul>
<li>async是generator函数的语法糖</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 读取文件</span></span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>); </span><br><span class="line"><span class="keyword">const</span> readFile = <span class="function"><span class="keyword">function</span> (<span class="params">fileName</span>) </span>&#123; </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123; </span><br><span class="line">        fs.readFile(fileName, <span class="function"><span class="keyword">function</span>(<span class="params">error, data</span>) </span>&#123; </span><br><span class="line">            <span class="keyword">if</span> (error) <span class="keyword">return</span> reject(error); </span><br><span class="line">            resolve(data); </span><br><span class="line">        &#125;); </span><br><span class="line">    &#125;); </span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// generator函数写法</span></span><br><span class="line"><span class="keyword">const</span> gen = <span class="function"><span class="keyword">function</span>* (<span class="params"></span>) </span>&#123; </span><br><span class="line">    <span class="keyword">const</span> f1 = <span class="keyword">yield</span> readFile(<span class="string">'/etc/fstab'</span>); </span><br><span class="line">    <span class="keyword">const</span> f2 = <span class="keyword">yield</span> readFile(<span class="string">'/etc/shells'</span>); </span><br><span class="line">    <span class="built_in">console</span>.log(f1.toString()); </span><br><span class="line">    <span class="built_in">console</span>.log(f2.toString()); </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// async函数写法</span></span><br><span class="line"><span class="keyword">const</span> asyncReadFile = <span class="keyword">async</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; </span><br><span class="line">    <span class="keyword">const</span> f1 = <span class="keyword">await</span> readFile(<span class="string">'/etc/fstab'</span>); </span><br><span class="line">    <span class="keyword">const</span> f2 = <span class="keyword">await</span> readFile(<span class="string">'/etc/shells'</span>); </span><br><span class="line">    <span class="built_in">console</span>.log(f1.toString()); </span><br><span class="line">    <span class="built_in">console</span>.log(f2.toString()); </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将generator函数的*替换成async  将yield替换成await</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// async函数对generator函数的改进  （1）generator函数的执行必须依靠执行器（调用next方法或co模块）而async函数自带执行器 即与普通函数一样  asyncReadFile()</span></span><br><span class="line"><span class="comment">// （2）async和await 比起*和yield  语义更加清楚</span></span><br><span class="line"><span class="comment">// （3）co 模块约定， yield 命令后面只能是 Thunk 函数或 Promise 对象， 而 async 函数的 await 命令后面，可以是Promise 对象和原始类型的 值（数值、字符串和布尔值，但这时等同于同步操作）</span></span><br><span class="line"><span class="comment">// （4）返回值是promise  可以用then方法指定下一步的操作</span></span><br></pre></td></tr></table></figure>
<h3 id="基本用法"><a class="header-anchor" href="#基本用法">¶</a>基本用法</h3>
<ul>
<li>async函数返回一个Promise对象  可以用then方法添加回调函数  当函数执行的时候  一旦遇到await就会先返回  等到异步操作完成  再接着执行函数体内后面的语句</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">timeout</span>(<span class="params">ms</span>) </span>&#123; </span><br><span class="line">    <span class="keyword">await</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123; </span><br><span class="line">        setTimeout(resolve, ms); </span><br><span class="line">    &#125;); </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">asyncPrint</span>(<span class="params">value, ms</span>) </span>&#123; </span><br><span class="line">    <span class="keyword">await</span> timeout(ms); </span><br><span class="line">    <span class="built_in">console</span>.log(value); </span><br><span class="line">&#125;</span><br><span class="line">asyncPrint(<span class="string">'hello world'</span>, <span class="number">50</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数声明</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="comment">// 函数表达式</span></span><br><span class="line"><span class="keyword">const</span> foo = <span class="keyword">async</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line"><span class="comment">// 箭头函数</span></span><br><span class="line"><span class="keyword">const</span> foo = <span class="keyword">async</span> () =&gt; &#123;&#125;;</span><br><span class="line"><span class="comment">// class方法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Storage</span> </span>&#123; </span><br><span class="line">    <span class="keyword">constructor</span>() &#123; </span><br><span class="line">        <span class="keyword">this</span>.cachePromise = caches.open(<span class="string">'avatars'</span>); </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">async</span> getAvatar(name) &#123; </span><br><span class="line">        <span class="keyword">const</span> cache = <span class="keyword">await</span> <span class="keyword">this</span>.cachePromise; </span><br><span class="line">        <span class="keyword">return</span> cache.match(<span class="string">`/avatars/<span class="subst">$&#123;name&#125;</span>.jpg`</span>); </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> storage = <span class="keyword">new</span> Storage(); </span><br><span class="line">storage.getAvatar(<span class="string">'jake'</span>).then(…);</span><br></pre></td></tr></table></figure>
<h3 id="语法"><a class="header-anchor" href="#语法">¶</a>语法</h3>
<h4 id="返回promise对象"><a class="header-anchor" href="#返回promise对象">¶</a>返回promise对象</h4>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// async函数返回一个promise对象  async函数内部return语句返回的值  会成为then方法回调函数的参数</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">    <span class="keyword">return</span> <span class="string">'hello world'</span>; </span><br><span class="line">&#125;</span><br><span class="line">f().then(<span class="function"><span class="params">v</span> =&gt;</span> <span class="built_in">console</span>.log(v)) <span class="comment">// "hello world"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// async函数内部抛出错误  会导致返回的promise对象变为reject状态 抛出的错误会被catch方法回调函数接收</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'出错了'</span>); </span><br><span class="line">&#125;</span><br><span class="line">f().then( </span><br><span class="line">    v =&gt; <span class="built_in">console</span>.log(v), </span><br><span class="line">    e =&gt; <span class="built_in">console</span>.log(e) </span><br><span class="line">)<span class="comment">// Error: 出错了</span></span><br></pre></td></tr></table></figure>
<h4 id="promise对象的状态变化"><a class="header-anchor" href="#promise对象的状态变化">¶</a>promise对象的状态变化</h4>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// async函数返回的promise对象  必须等到内部所有await命令后面的promise对象执行完 才会发生状态改变  除非遇到return语句或抛出错误</span></span><br><span class="line"><span class="comment">// 只有 async 函数内部的异步操作执行完，才会执行 then 方法指定的回调函数</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">getTitle</span>(<span class="params">url</span>) </span>&#123; </span><br><span class="line">    <span class="keyword">let</span> response = <span class="keyword">await</span> fetch(url); </span><br><span class="line">    <span class="keyword">let</span> html = <span class="keyword">await</span> response.text(); </span><br><span class="line">    <span class="keyword">return</span> html.match(<span class="regexp">/&lt;title&gt;([\s\S]+)&lt;\/title&gt;/i</span>)[<span class="number">1</span>]; </span><br><span class="line">&#125;</span><br><span class="line">getTitle(<span class="string">'https://tc39.github.io/ecma262/'</span>).then(<span class="built_in">console</span> .log) </span><br><span class="line"><span class="comment">// "ECMAScript 2017 Language Specification"</span></span><br><span class="line"><span class="comment">// 上述函数存在三个操作  只有等这三个操作全部完成  才会执行then方法里的console.log</span></span><br></pre></td></tr></table></figure>
<h4 id="await命令"><a class="header-anchor" href="#await命令">¶</a>await命令</h4>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 正常情况下 await命令后面是一个promise对象  如果不是 会被转成一个立即resolve的promise对象</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">await</span> <span class="number">123</span>; </span><br><span class="line">&#125;</span><br><span class="line">f().then(<span class="function"><span class="params">v</span> =&gt;</span> <span class="built_in">console</span>.log(v)) <span class="comment">// 123</span></span><br><span class="line"><span class="comment">// 上面代码中 await 命令的参数是数值 123  它被转成 Promise 对象 并立即 resolve</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// await命令后面的promise对象如果变成reject状态  则reject的参数会被catch方法的回调接收到</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">    <span class="keyword">await</span> <span class="built_in">Promise</span>.reject(<span class="string">'出错了'</span>); </span><br><span class="line">&#125;</span><br><span class="line">f()</span><br><span class="line">.then(<span class="function"><span class="params">v</span> =&gt;</span> <span class="built_in">console</span>.log(v))</span><br><span class="line">.catch(<span class="function"><span class="params">e</span> =&gt;</span> <span class="built_in">console</span>.log(e)) <span class="comment">// 出错了</span></span><br><span class="line"><span class="comment">// 只要一个await语句后面的promise变成reject 那么整个async函数都会中断执行</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果希望即使一个异步操作失败 后面也能继续进行 可以使用try...catch</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">    <span class="keyword">try</span> &#123; </span><br><span class="line">        <span class="keyword">await</span> <span class="built_in">Promise</span>.reject(<span class="string">'出错了'</span>); </span><br><span class="line">    &#125; <span class="keyword">catch</span>(e) &#123; &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">await</span> <span class="built_in">Promise</span>.resolve(<span class="string">'hello world'</span>); &#125;</span><br><span class="line">f().then(<span class="function"><span class="params">v</span> =&gt;</span> <span class="built_in">console</span>.log(v)) <span class="comment">// hello world</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 另一种方法是await后面的promise对象再跟一个catch方法  处理前面可能出现的错误</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">    <span class="keyword">await</span> <span class="built_in">Promise</span>.reject(<span class="string">'出错了'</span>).catch(<span class="function"><span class="params">e</span> =&gt;</span> <span class="built_in">console</span>.log(e)); </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">await</span> <span class="built_in">Promise</span>.resolve(<span class="string">'hello world'</span>); </span><br><span class="line">&#125;</span><br><span class="line">f().then(<span class="function"><span class="params">v</span> =&gt;</span> <span class="built_in">console</span>.log(v)) </span><br><span class="line"><span class="comment">// 出错了 </span></span><br><span class="line"><span class="comment">// hello world</span></span><br></pre></td></tr></table></figure>
<h4 id="错误处理"><a class="header-anchor" href="#错误处理">¶</a>错误处理</h4>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果await后面的异步操作出错 等同于async函数返回的promise对象被reject</span></span><br><span class="line"><span class="comment">// 如果有多个await命令 可以统一放在try...catch结构中</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">main</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">    <span class="keyword">try</span> &#123; </span><br><span class="line">        <span class="keyword">const</span> val1 = <span class="keyword">await</span> firstStep(); </span><br><span class="line">        <span class="keyword">const</span> val2 = <span class="keyword">await</span> secondStep(val1); </span><br><span class="line">        <span class="keyword">const</span> val3 = <span class="keyword">await</span> thirdStep(val1, val2); </span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'Final: '</span>, val3); </span><br><span class="line">    &#125;<span class="keyword">catch</span> (err) &#123; </span><br><span class="line">        <span class="built_in">console</span>.error(err); </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 利用try...catch结构 实现多次重复尝试</span></span><br><span class="line"><span class="keyword">const</span> superagent = <span class="built_in">require</span>(<span class="string">'superagent'</span>); </span><br><span class="line"><span class="keyword">const</span> NUM_RETRIES = <span class="number">3</span>; </span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">    <span class="keyword">let</span> i; </span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; NUM_RETRIES; ++i) &#123; </span><br><span class="line">        <span class="keyword">try</span> &#123; </span><br><span class="line">            <span class="keyword">await</span> superagent.get(<span class="string">'http://google.com/this- throws-an-error'</span>); </span><br><span class="line">            <span class="keyword">break</span>; </span><br><span class="line">        &#125; <span class="keyword">catch</span>(err) &#123;&#125; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">console</span>.log(i); <span class="comment">// 3 </span></span><br><span class="line">&#125;</span><br><span class="line">test();</span><br><span class="line"><span class="comment">// 如果await成功 就会break语句退出循环 如果失败就会被catch语句捕获 进入下一轮循环</span></span><br></pre></td></tr></table></figure>
<h3 id="使用注意点"><a class="header-anchor" href="#使用注意点">¶</a>使用注意点</h3>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// （1）最好把await命令放在try...catch中</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">myFunction</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">    <span class="keyword">try</span> &#123; </span><br><span class="line">        <span class="keyword">await</span> somethingThatReturnsAPromise(); </span><br><span class="line">    &#125; <span class="keyword">catch</span> (err) &#123; </span><br><span class="line">        <span class="built_in">console</span>.log(err); </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 另一种写法 </span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">myFunction</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">    <span class="keyword">await</span> somethingThatReturnsAPromise().catch(<span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123; </span><br><span class="line">        <span class="built_in">console</span>.log(err); </span><br><span class="line">    &#125;); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// （2）多个await命令后面的异步操作 如果不存在继发关系 最好同时触发</span></span><br><span class="line"><span class="comment">// 继发</span></span><br><span class="line"><span class="keyword">let</span> foo = <span class="keyword">await</span> getFoo(); </span><br><span class="line"><span class="keyword">let</span> bar = <span class="keyword">await</span> getBar();</span><br><span class="line"><span class="comment">// 写法一</span></span><br><span class="line"><span class="keyword">let</span> [foo, bar] = <span class="keyword">await</span> <span class="built_in">Promise</span>.all([getFoo(), getBar()]);</span><br><span class="line"><span class="comment">// 写法二</span></span><br><span class="line"><span class="keyword">let</span> fooPromise = getFoo(); </span><br><span class="line"><span class="keyword">let</span> barPromise = getBar(); </span><br><span class="line"><span class="keyword">let</span> foo = <span class="keyword">await</span> fooPromise; </span><br><span class="line"><span class="keyword">let</span> bar = <span class="keyword">await</span> barPromise;</span><br><span class="line"></span><br><span class="line"><span class="comment">// （3）await命令只能用在async函数中 如果用在普通函数会报错</span></span><br></pre></td></tr></table></figure>
<h3 id="async函数的实现原理"><a class="header-anchor" href="#async函数的实现原理">¶</a>async函数的实现原理</h3>
<ul>
<li>将generator函数和自动执行器 包装在一个函数里</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">args</span>) </span>&#123; </span><br><span class="line">    <span class="comment">// ... </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 等同于 </span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">args</span>) </span>&#123; </span><br><span class="line">    <span class="keyword">return</span> spawn(<span class="function"><span class="keyword">function</span>* (<span class="params"></span>) </span>&#123; </span><br><span class="line">        <span class="comment">// ... </span></span><br><span class="line">    &#125;); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// spawn函数就是自动执行器  下面是实现原理</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">spawn</span>(<span class="params">genF</span>) </span>&#123; </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123; </span><br><span class="line">        <span class="keyword">const</span> gen = genF(); </span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">step</span>(<span class="params">nextF</span>) </span>&#123; </span><br><span class="line">            <span class="keyword">let</span> next; </span><br><span class="line">            <span class="keyword">try</span> &#123; </span><br><span class="line">                next = nextF(); </span><br><span class="line">            &#125; <span class="keyword">catch</span>(e) &#123; </span><br><span class="line">                <span class="keyword">return</span> reject(e); </span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(next.done) &#123; </span><br><span class="line">                <span class="keyword">return</span> resolve(next.value);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">Promise</span>.resolve(next.value).then(<span class="function"><span class="keyword">function</span>(<span class="params">v</span>) </span>&#123; </span><br><span class="line">                step(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">                    <span class="keyword">return</span> gen.next(v); </span><br><span class="line">                &#125;); </span><br><span class="line">            &#125;, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123; </span><br><span class="line">                step(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">                    <span class="keyword">return</span> gen.throw(e); </span><br><span class="line">                &#125;); </span><br><span class="line">            &#125;); </span><br><span class="line">        &#125;step(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">            <span class="keyword">return</span> gen.next(<span class="literal">undefined</span>); </span><br><span class="line">        &#125;); </span><br><span class="line">    &#125;); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="与其他异步处理方法的比较"><a class="header-anchor" href="#与其他异步处理方法的比较">¶</a>与其他异步处理方法的比较</h3>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// promise</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">chainAnimationsPromise</span>(<span class="params">elem, animations</span>) </span>&#123; </span><br><span class="line">    <span class="comment">// 变量ret用来保存上一个动画的返回值 </span></span><br><span class="line">    <span class="keyword">let</span> ret = <span class="literal">null</span>; </span><br><span class="line">    <span class="comment">// 新建一个空的Promise </span></span><br><span class="line">    <span class="keyword">let</span> p = <span class="built_in">Promise</span>.resolve(); </span><br><span class="line">    <span class="comment">// 使用then方法，添加所有动画 </span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> anim <span class="keyword">of</span> animations) &#123; </span><br><span class="line">        p = p.then(<span class="function"><span class="keyword">function</span>(<span class="params">val</span>) </span>&#123; </span><br><span class="line">            ret = val; </span><br><span class="line">            <span class="keyword">return</span> anim(elem); </span><br><span class="line">        &#125;); </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回一个部署了错误捕捉机制的Promise </span></span><br><span class="line">    <span class="keyword">return</span> p.catch(<span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123; </span><br><span class="line">        <span class="comment">/* 忽略错误，继续执行 */</span> </span><br><span class="line">    &#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">        <span class="keyword">return</span> ret; </span><br><span class="line">    &#125;); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// generator函数  spawn是自动执行器</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">chainAnimationsGenerator</span>(<span class="params">elem, animations</span>) </span>&#123; </span><br><span class="line">    <span class="keyword">return</span> spawn(<span class="function"><span class="keyword">function</span>*(<span class="params"></span>) </span>&#123; </span><br><span class="line">        <span class="keyword">let</span> ret = <span class="literal">null</span>; </span><br><span class="line">        <span class="keyword">try</span> &#123; </span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">let</span> anim <span class="keyword">of</span> animations) &#123; </span><br><span class="line">                ret = <span class="keyword">yield</span> anim(elem); </span><br><span class="line">            &#125; </span><br><span class="line">        &#125; <span class="keyword">catch</span>(e) &#123; </span><br><span class="line">            <span class="comment">/* 忽略错误，继续执行 */</span> </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret; </span><br><span class="line">    &#125;); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// async函数</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">chainAnimationsAsync</span>(<span class="params">elem, animations</span>) </span>&#123; </span><br><span class="line">    <span class="keyword">let</span> ret = <span class="literal">null</span>; </span><br><span class="line">    <span class="keyword">try</span> &#123; </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> anim <span class="keyword">of</span> animations) &#123; </span><br><span class="line">            ret = <span class="keyword">await</span> anim(elem); </span><br><span class="line">        &#125; </span><br><span class="line">    &#125; <span class="keyword">catch</span>(e) &#123; </span><br><span class="line">        <span class="comment">/* 忽略错误，继续执行 */</span> </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article id="post-2、变量的解构赋值" class="h-entry post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time class="dt-published" datetime="2020-07-21T01:13:28.000Z"><a href="/2020/07/21/2、变量的解构赋值/">2020-07-21</a></time>
      
      
  
    <h1 class="title"><a href="/2020/07/21/2、变量的解构赋值/">2、变量的解构赋值</a></h1>
  

    </header>
    <div class="e-content entry" itemprop="articleBody">
      
        <p>[TOC]</p>
<h2 id="解构赋值"><a class="header-anchor" href="#解构赋值">¶</a>解构赋值</h2>
<ul>
<li>当使用解构赋值时  解构赋值的变量会重新声明  所以不能使用<code>let</code>和<code>const</code>提前声明</li>
</ul>
<h3 id="数组的解构赋值"><a class="header-anchor" href="#数组的解构赋值">¶</a>数组的解构赋值</h3>
<ul>
<li>模式匹配  左右模式相同就可以解构赋值</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> [a, b, c] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>] <span class="comment">// a=1 b=2 c=3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 嵌套</span></span><br><span class="line"><span class="keyword">let</span> [foo, [[bar], baz]] = [<span class="number">1</span>, [[<span class="number">2</span>], <span class="number">3</span>]];<span class="comment">// foo=1 bar=2 baz=3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 空位</span></span><br><span class="line"><span class="keyword">let</span> [x, , y] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]; <span class="comment">// x=1  y=3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 扩展运算符</span></span><br><span class="line"><span class="keyword">let</span> [head, ...tail] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]; <span class="comment">//  head=1  tail=[2, 3, 4]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 左大于右</span></span><br><span class="line"><span class="keyword">let</span> [x, y, ...z] = [<span class="string">'a'</span>]; <span class="comment">// x="a"  y=undefined  z=[]</span></span><br><span class="line"><span class="comment">// 如果解构赋值不成功  变量的值就等于undefined  扩展运算符后的变量为[]</span></span><br><span class="line"><span class="comment">// 解构赋值不成功  左边的变量多于右边的值</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 不完全解构  右大于左</span></span><br><span class="line"><span class="keyword">let</span> [x, y] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]; <span class="comment">// x=1  y=2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 解构赋值失败  等号右边不是可遍历的结构(转为对象后不具备Iterator接口  前五种  本身不具备Iterator接口  最后一种)</span></span><br><span class="line"><span class="keyword">let</span> [foo] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">let</span> [foo] = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">let</span> [foo] = <span class="literal">NaN</span>;</span><br><span class="line"><span class="keyword">let</span> [foo] = <span class="literal">undefined</span>;</span><br><span class="line"><span class="keyword">let</span> [foo] = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">let</span> [foo] = &#123;&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="默认值"><a class="header-anchor" href="#默认值">¶</a>默认值</h3>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 当一个数组成员严格等于(===)undefined  默认值生效</span></span><br><span class="line"><span class="keyword">var</span> [x = <span class="number">1</span>] = [<span class="literal">undefined</span>];</span><br><span class="line">x <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 默认值可以引用解构赋值的其他变量  但该变量必须已经声明</span></span><br><span class="line"><span class="keyword">let</span> [x = <span class="number">1</span>, y = x] = [<span class="number">1</span>, <span class="number">2</span>]; <span class="comment">// x=1; y=2</span></span><br><span class="line"><span class="keyword">let</span> [x = y, y = <span class="number">1</span>] = [];     <span class="comment">// ReferenceError</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 对象的属性值严格等于undefined</span></span><br><span class="line"><span class="keyword">var</span> &#123;x = <span class="number">3</span>&#125; = &#123;<span class="attr">x</span>: <span class="literal">null</span>&#125;;</span><br><span class="line">x <span class="comment">// null</span></span><br></pre></td></tr></table></figure>
<h3 id="对象的解构赋值"><a class="header-anchor" href="#对象的解构赋值">¶</a>对象的解构赋值</h3>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 对象解构赋值中  变量名必须与属性名相同才能取到值</span></span><br><span class="line"><span class="keyword">var</span> &#123; foo, bar &#125; = &#123; <span class="attr">foo</span>: <span class="string">"aaa"</span>, <span class="attr">bar</span>: <span class="string">"bbb"</span> &#125;; <span class="comment">// foo="aaa"  bar"bbb"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> &#123; baz &#125; = &#123; <span class="attr">foo</span>: <span class="string">"aaa"</span>, <span class="attr">bar</span>: <span class="string">"bbb"</span> &#125;; <span class="comment">// baz=undefined</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 变量名与属性名不同的解决方法</span></span><br><span class="line"><span class="keyword">var</span> &#123; <span class="attr">foo</span>: baz &#125; = &#123; <span class="attr">foo</span>: <span class="string">'aaa'</span>, <span class="attr">bar</span>: <span class="string">'bbb'</span> &#125;; <span class="comment">// baz="aaa"</span></span><br><span class="line"><span class="comment">// foo是匹配模式  baz是变量  </span></span><br><span class="line"><span class="comment">// 详细写法</span></span><br><span class="line"><span class="keyword">var</span> &#123; <span class="attr">foo</span>: foo, <span class="attr">bar</span>: bar &#125; = &#123; <span class="attr">foo</span>: <span class="string">"aaa"</span>, <span class="attr">bar</span>: <span class="string">"bbb"</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 嵌套  p是模式  x y才是变量</span></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  p: [</span><br><span class="line">    <span class="string">'Hello'</span>,</span><br><span class="line">    &#123; <span class="attr">y</span>: <span class="string">'World'</span> &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> &#123; <span class="attr">p</span>: [x, &#123; y &#125;] &#125; = obj;</span><br><span class="line">x <span class="comment">// "Hello"</span></span><br><span class="line">y <span class="comment">// "World"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 解构失败  变量的值为undefined</span></span><br><span class="line"><span class="comment">// 如果解构赋值是嵌套的对象  而且子对象的父属性不存在  会报错</span></span><br><span class="line"><span class="keyword">var</span> &#123;<span class="attr">foo</span>: &#123;bar&#125;&#125; = &#123;<span class="attr">baz</span>: <span class="string">'baz'</span>&#125;; <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure>
<h3 id="字符串的解构赋值"><a class="header-anchor" href="#字符串的解构赋值">¶</a>字符串的解构赋值</h3>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将字符串转换为数组</span></span><br><span class="line"><span class="keyword">const</span> [a, b, c, d, e] = <span class="string">'hello'</span>;</span><br><span class="line">a <span class="comment">// "h"</span></span><br><span class="line">b <span class="comment">// "e"</span></span><br><span class="line">c <span class="comment">// "l"</span></span><br><span class="line">d <span class="comment">// "l"</span></span><br><span class="line">e <span class="comment">// "o"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 转换为对象  </span></span><br><span class="line"><span class="keyword">let</span> &#123;<span class="attr">length</span> : len&#125; = <span class="string">'hello'</span>;</span><br><span class="line">len <span class="comment">// 5</span></span><br></pre></td></tr></table></figure>
<h3 id="数值和布尔值的解构赋值"><a class="header-anchor" href="#数值和布尔值的解构赋值">¶</a>数值和布尔值的解构赋值</h3>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果等号右边是数值和bool  会先转换为对象</span></span><br><span class="line"><span class="keyword">let</span> &#123;<span class="attr">toString</span>: s&#125; = <span class="number">123</span>;</span><br><span class="line">s === <span class="built_in">Number</span>.prototype.toString <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> &#123;<span class="attr">toString</span>: s&#125; = <span class="literal">true</span>;</span><br><span class="line">s === <span class="built_in">Boolean</span>.prototype.toString <span class="comment">// true</span></span><br><span class="line"><span class="comment">// 只要等号右边不是对象  就先将其转换为对象  null和undefined无法转换为对象  所以解构赋值会报错</span></span><br><span class="line"><span class="keyword">let</span> &#123; <span class="attr">prop</span>: x &#125; = <span class="literal">undefined</span>; <span class="comment">// TypeError</span></span><br><span class="line"><span class="keyword">let</span> &#123; <span class="attr">prop</span>: y &#125; = <span class="literal">null</span>; <span class="comment">// TypeError</span></span><br></pre></td></tr></table></figure>
<h3 id="圆括号问题"><a class="header-anchor" href="#圆括号问题">¶</a>圆括号问题</h3>
<h4 id="不能使用圆括号的情况"><a class="header-anchor" href="#不能使用圆括号的情况">¶</a>不能使用圆括号的情况</h4>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 变量声明语句  不能带有圆括号</span></span><br><span class="line"><span class="keyword">var</span> [(a)] = [<span class="number">1</span>];</span><br><span class="line"><span class="keyword">var</span> &#123;<span class="attr">x</span>: (c)&#125; = &#123;&#125;;</span><br><span class="line"><span class="keyword">var</span> (&#123;<span class="attr">x</span>: c&#125;) = &#123;&#125;;</span><br><span class="line"><span class="keyword">var</span> &#123;(x: c)&#125; = &#123;&#125;;</span><br><span class="line"><span class="keyword">var</span> &#123;(x): c&#125; = &#123;&#125;;</span><br><span class="line"><span class="keyword">var</span> &#123; <span class="attr">o</span>: (&#123; <span class="attr">p</span>: p &#125;) &#125; = &#123; <span class="attr">o</span>: &#123; <span class="attr">p</span>: <span class="number">2</span> &#125; &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数参数中  模式不能带有圆括号</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">[(z</span>)]) </span>&#123; <span class="keyword">return</span> z; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 赋值语句中  不能将整个模式或嵌套模式中的一层放在圆括号中</span></span><br><span class="line">(&#123; <span class="attr">p</span>: a &#125;) = &#123; <span class="attr">p</span>: <span class="number">42</span> &#125;;</span><br><span class="line">([a]) = [<span class="number">5</span>];</span><br><span class="line">[(&#123; <span class="attr">p</span>: a &#125;), &#123; <span class="attr">x</span>: c &#125;] = [&#123;&#125;, &#123;&#125;];</span><br></pre></td></tr></table></figure>
<h4 id="可以使用圆括号的情况"><a class="header-anchor" href="#可以使用圆括号的情况">¶</a>可以使用圆括号的情况</h4>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 赋值语句的非模式部分  可以使用圆括号</span></span><br><span class="line">[(b)] = [<span class="number">3</span>]; <span class="comment">// 正确</span></span><br><span class="line">(&#123; <span class="attr">p</span>: (d) &#125; = &#123;&#125;); <span class="comment">// 正确</span></span><br><span class="line">[(<span class="built_in">parseInt</span>.prop)] = [<span class="number">3</span>]; <span class="comment">// 正确</span></span><br></pre></td></tr></table></figure>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article id="post-1、let和const命令" class="h-entry post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time class="dt-published" datetime="2020-07-21T01:11:51.000Z"><a href="/2020/07/21/1、let和const命令/">2020-07-21</a></time>
      
      
  
    <h1 class="title"><a href="/2020/07/21/1、let和const命令/">1、let和const命令</a></h1>
  

    </header>
    <div class="e-content entry" itemprop="articleBody">
      
        <p>[TOC]</p>
<h2 id="let和const"><a class="header-anchor" href="#let和const">¶</a>let和const</h2>
<h3 id="let"><a class="header-anchor" href="#let">¶</a>let</h3>
<ul>
<li>
<p><code>let 变量=值</code></p>
</li>
<li>
<p>只在当前作用域内有效(可用于<code>for循环</code>) 即<code>{}</code> 这样的代码块</p>
</li>
</ul>
 <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 基本</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">let</span> a=<span class="number">10</span></span><br><span class="line">  <span class="keyword">var</span> b=<span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line">a <span class="comment">// ReferenceError: a is not defined</span></span><br><span class="line">b <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// var</span></span><br><span class="line"><span class="keyword">var</span> a = [];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">  a[i] = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line">a[<span class="number">6</span>](); <span class="comment">// 10</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// let</span></span><br><span class="line"><span class="keyword">var</span> a = [];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">  a[i] = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line">a[<span class="number">6</span>](); <span class="comment">// 6</span></span><br></pre></td></tr></table></figure>
<ul>
<li>不存在变量提升(提前声明)</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// var</span></span><br><span class="line"><span class="built_in">console</span>.log(foo)</span><br><span class="line"><span class="keyword">var</span> foo=<span class="number">2</span></span><br><span class="line"><span class="comment">// let</span></span><br><span class="line"><span class="built_in">console</span>.log(foo) <span class="comment">// 报错</span></span><br><span class="line"><span class="keyword">let</span> foo=<span class="number">2</span></span><br></pre></td></tr></table></figure>
<ul>
<li>存在暂停性死区(在变量声明前不能使用该变量)</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> tmp = <span class="number">123</span>; </span><br><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123; </span><br><span class="line">  tmp = <span class="string">'abc'</span>; <span class="comment">// ReferenceError </span></span><br><span class="line">  <span class="keyword">let</span> tmp; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>不允许重复声明</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 报错 </span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">  <span class="keyword">let</span> a = <span class="number">10</span>; </span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">1</span>; </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 报错 </span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">  <span class="keyword">let</span> a = <span class="number">10</span>; </span><br><span class="line">  <span class="keyword">let</span> a = <span class="number">1</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="使用var的风险"><a class="header-anchor" href="#使用var的风险">¶</a>使用var的风险</h4>
<ul>
<li>
<p>内层变量可能会覆盖外层变量 (提前声明)</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> tmp = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(tmp);</span><br><span class="line">  <span class="keyword">if</span> (<span class="literal">false</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> tmp = <span class="string">"hello world"</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f(); <span class="comment">// undefined</span></span><br><span class="line"><span class="comment">// 由于变量提升  内部的tmp覆盖了外部的tmp</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>用于循环计数的变量泄露为全局变量</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s = <span class="string">'hello'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; s.length; i++) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(s[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(i); <span class="comment">// 5</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="es6的块级作用域"><a class="header-anchor" href="#es6的块级作用域">¶</a>es6的块级作用域</h3>
<ul>
<li>
<p>只要是<code>{}</code>就是一个块级作用域</p>
</li>
<li>
<p>可以任意嵌套 内层作用域可以定义外层作用域的同名变量</p>
</li>
<li>
<p>允许在块级作用域中声明函数(<code>es5</code>前不允许 在严格模式下同样无效)</p>
</li>
<li>
<p>本质上<code>es6</code>的块级作用域是一个语句 将多个操作封装在一起(操作即作用域中的执行语句) 没有返回值(所有外层无法访问内层)</p>
</li>
<li>
<p>do{} 返回块级作用域最后执行的表达式的值 (不能使用)</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> x = <span class="keyword">do</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> t = f();</span><br><span class="line">  t * t + <span class="number">1</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="const"><a class="header-anchor" href="#const">¶</a>const</h3>
<ul>
<li>
<p><code>const 变量=值</code></p>
</li>
<li>
<p>声明一个只读的常量 值不能改变</p>
</li>
<li>
<p><code>const</code>一旦声明必须初始化(赋值)</p>
</li>
<li>
<p>不存在变量提升(提前声明)</p>
</li>
<li>
<p>存在暂停性死区(在变量声明前不能使用该变量)</p>
</li>
<li>
<p>不能重复声明</p>
</li>
<li>
<p><code>const</code>只是保证变量名指向的地址不变 但该地址的数据可能改变(使用<code>const</code>定义对象  该对象可以增删属性)</p>
</li>
<li>
<p>将对象冻结  <code>const 变量=Object.freeze( {} )</code> 不能增删属性</p>
</li>
</ul>
<h3 id="顶层对象的属性"><a class="header-anchor" href="#顶层对象的属性">¶</a>顶层对象的属性</h3>
<ul>
<li>
<p>顶层对象在浏览器环境指的是<code>window</code>对象 在node指的是<code>global</code>对象</p>
</li>
<li>
<p>在es5中 顶层对象的属性与全局变量是等价的</p>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.a=<span class="number">1</span></span><br><span class="line">a <span class="comment">// 1</span></span><br><span class="line">a=<span class="number">2</span></span><br><span class="line"><span class="built_in">window</span>.a <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>
<ul>
<li>在es6中 var命令和function命令声明的全局变量依然是顶层对象的属性 let const class命令声明的全局变量 不属于顶层对象的属性</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a=<span class="number">1</span></span><br><span class="line"><span class="built_in">window</span>.a <span class="comment">// 1</span></span><br><span class="line"><span class="keyword">let</span> b=<span class="number">1</span></span><br><span class="line"><span class="built_in">window</span>.b <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>
<h3 id="global对象"><a class="header-anchor" href="#global对象">¶</a>global对象</h3>
<ul>
<li>同一段代码不能在任何环境下都能拿到顶层对象</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方法一</span></span><br><span class="line">(<span class="keyword">typeof</span> <span class="built_in">window</span> !== <span class="string">'undefined'</span> </span><br><span class="line">? <span class="built_in">window</span> </span><br><span class="line">: (<span class="keyword">typeof</span> process === <span class="string">'object'</span> </span><br><span class="line">&amp;&amp; <span class="keyword">typeof</span> <span class="built_in">require</span> === <span class="string">'function'</span> </span><br><span class="line">&amp;&amp; <span class="keyword">typeof</span> global === <span class="string">'object'</span>) </span><br><span class="line">? global </span><br><span class="line">: <span class="keyword">this</span>)</span><br><span class="line"><span class="comment">// 方法二</span></span><br><span class="line"><span class="keyword">var</span> getGlobal = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; </span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> self !== <span class="string">'undefined'</span>) &#123; <span class="keyword">return</span> self &#125; </span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="built_in">window</span> !== <span class="string">'undefined'</span>) &#123; <span class="keyword">return</span> <span class="built_in">window</span> &#125; </span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> global !== <span class="string">'undefined'</span>) &#123; <span class="keyword">return</span> global &#125; </span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'unable to locate global object'</span>); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>引入global 在所有环境中都可以通过global获取顶层对象</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// commonJS写法</span></span><br><span class="line"><span class="keyword">var</span> global=<span class="built_in">require</span>(<span class="string">'system.global'</span>)()</span><br><span class="line"><span class="comment">// es6模块写法 </span></span><br><span class="line"><span class="keyword">import</span> getGlobal <span class="keyword">from</span> <span class="string">'system.global'</span></span><br><span class="line"><span class="keyword">const</span> global=getGlobal()</span><br></pre></td></tr></table></figure>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article id="post-14、Generator函数" class="h-entry post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time class="dt-published" datetime="2020-07-19T14:06:09.000Z"><a href="/2020/07/19/14、Generator函数/">2020-07-19</a></time>
      
      
  
    <h1 class="title"><a href="/2020/07/19/14、Generator函数/">Generator函数</a></h1>
  

    </header>
    <div class="e-content entry" itemprop="articleBody">
      
        <p>[TOC]</p>
<h2 id="Generator"><a class="header-anchor" href="#Generator">¶</a>Generator</h2>
<ul>
<li><code>generator</code>函数是一个状态机  封装了多个内部状态</li>
<li>执行<code>generator</code>函数会返回一个遍历器对象</li>
<li>返回的遍历器对象 可以一次遍历<code>generator</code>函数内部的每一个状态</li>
</ul>
<ol>
<li><code>function</code>关键字与函数名之间有一个星号</li>
<li>函数体内部使用<code>yield(产出)</code>表达式   定义不同的内部状态</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">helloWorldGenerator</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">    <span class="keyword">yield</span> <span class="string">'hello'</span>; </span><br><span class="line">    <span class="keyword">yield</span> <span class="string">'world'</span>; </span><br><span class="line">    <span class="keyword">return</span> <span class="string">'ending'</span>; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> hw = helloWorldGenerator()</span><br><span class="line"><span class="comment">// 内部有两个yield表达式  即函数有三个状态</span></span><br><span class="line"><span class="comment">// hello world return 三个状态</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用方法与普通函数一样  函数名()   </span></span><br><span class="line"><span class="comment">// 调用generator函数后 函数并不执行  返回以恶执行内部状态的指针对象（遍历器对象）</span></span><br><span class="line"><span class="comment">// 调用遍历器对象的next方法  使指针指向下一个状态  每次调用next方法 内部指针就从函数头部或上一次停下来的地方开始执行  直到遇到下一个yield表达式为止（或return）</span></span><br><span class="line"><span class="comment">// value属性的值为当前的状态值  done属性值为是否完毕</span></span><br><span class="line">hw.next() </span><br><span class="line"><span class="comment">// &#123; value: 'hello', done: false &#125; </span></span><br><span class="line">hw.next() </span><br><span class="line"><span class="comment">// &#123; value: 'world', done: false &#125; </span></span><br><span class="line">hw.next() </span><br><span class="line"><span class="comment">// &#123; value: 'ending', done: true &#125; </span></span><br><span class="line">hw.next() </span><br><span class="line"><span class="comment">// &#123; value: undefined, done: true &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> * <span class="title">foo</span>(<span class="params">x, y</span>) </span>&#123; ··· &#125; </span><br><span class="line"><span class="function"><span class="keyword">function</span> *<span class="title">foo</span>(<span class="params">x, y</span>) </span>&#123; ··· &#125; </span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">foo</span>(<span class="params">x, y</span>) </span>&#123; ··· &#125; </span><br><span class="line"><span class="function"><span class="keyword">function</span>*<span class="title">foo</span>(<span class="params">x, y</span>) </span>&#123; ··· &#125;</span><br><span class="line"><span class="comment">// 这四种写法每一种都可以</span></span><br></pre></td></tr></table></figure>
<h3 id="yield表达式"><a class="header-anchor" href="#yield表达式">¶</a>yield表达式</h3>
<ul>
<li>遍历器对象<code>next</code>方法的运行逻辑</li>
</ul>
<ol>
<li>遇到<code>yield</code>表达式  就暂停执行后面的操作  并将紧跟在<code>yield</code>后面的那个表达式的值   作为返回的对象的<code>value</code>属性值</li>
<li>下一次调用<code>next</code>方法时   再继续往下执行   直到遇到下一 个<code>yield</code>表达式</li>
<li>如果没有再遇到新的<code>yield</code>表达式   就一直运行到函数结束   直到<code>return</code>语句为止   并将<code>return</code>语句后面的表达式的值   作为返回 的对象的<code>value</code>属性值</li>
<li>如果该函数没有 return 语句   则返回的对象的<code>value</code>属性值为<code>undefined</code></li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// yield后面的表达式只有当调用next方法 内部指针指向该语句时才会执行</span></span><br><span class="line"><span class="comment">// yield表达式只能用在generator函数中  其他地方会报错</span></span><br><span class="line"><span class="comment">// yield如果在另一个表达式中  必须放在圆括号里</span></span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">demo</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Hello'</span> + <span class="keyword">yield</span>); <span class="comment">// SyntaxError </span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Hello'</span> + <span class="keyword">yield</span> <span class="number">123</span>); <span class="comment">// SyntaxError </span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Hello'</span> + (<span class="keyword">yield</span>)); <span class="comment">// OK </span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Hello'</span> + (<span class="keyword">yield</span> <span class="number">123</span>)); <span class="comment">// OK </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// yield用作函数参数或放在赋值表达式的右边  可以不加括号</span></span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">demo</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">    foo(<span class="keyword">yield</span> <span class="string">'a'</span>, <span class="keyword">yield</span> <span class="string">'b'</span>); <span class="comment">// OK </span></span><br><span class="line">    <span class="keyword">let</span> input = <span class="keyword">yield</span>; <span class="comment">// OK </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="与Iterator接口的关系"><a class="header-anchor" href="#与Iterator接口的关系">¶</a>与Iterator接口的关系</h3>
<ul>
<li>任意一个对象的<code>Symbol.iterator</code>方法   等于该对象的遍历器生成函数   调用该函数会返回该对象的一个遍历器对象</li>
<li>由于<code>Generator</code>函数就是遍历器生成函数   因此可以把<code>Generator</code>赋值给对象的<code>Symbol.iterator</code>属性   从而使得该对象具有<code>Iterator</code>接口</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myIterable = &#123;&#125;; </span><br><span class="line">myIterable[<span class="built_in">Symbol</span>.iterator] = <span class="function"><span class="keyword">function</span>* (<span class="params"></span>) </span>&#123; </span><br><span class="line">    <span class="keyword">yield</span> <span class="number">1</span>; </span><br><span class="line">    <span class="keyword">yield</span> <span class="number">2</span>; </span><br><span class="line">    <span class="keyword">yield</span> <span class="number">3</span>; </span><br><span class="line">&#125;;</span><br><span class="line">[...myIterable] <span class="comment">// [1, 2, 3]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// generator函数执行后返回一个遍历器对象  该对象本身也具备Symbol.iterator属性  执行后返回自身</span></span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">gen</span>(<span class="params"></span>)</span>&#123; </span><br><span class="line">    <span class="comment">// some code </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> g = gen(); </span><br><span class="line">g[<span class="built_in">Symbol</span>.iterator]() === g <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<h3 id="next方法的参数"><a class="header-anchor" href="#next方法的参数">¶</a>next方法的参数</h3>
<ul>
<li>yield表达式本身没有返回值（undefined） next方法可以带一个参数  该参数会被当做上一个yield表达式的返回值</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">f</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; <span class="literal">true</span>; i++) &#123; </span><br><span class="line">        <span class="keyword">var</span> reset = <span class="keyword">yield</span> i; </span><br><span class="line">        <span class="keyword">if</span>(reset) &#123; <span class="comment">// 如果不传递参数 yield表达式的返回值是undefined</span></span><br><span class="line">            i = <span class="number">-1</span>; </span><br><span class="line">        &#125; </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> g = f(); </span><br><span class="line">g.next() <span class="comment">// &#123; value: 0, done: false &#125; </span></span><br><span class="line">g.next() <span class="comment">// &#123; value: 1, done: false &#125; </span></span><br><span class="line">g.next(<span class="literal">true</span>) <span class="comment">// &#123; value: 0, done: false &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//如 果next方法没有参数  每次运行到yield表达式  变量reset的值总是undefined  当next方法带一个参数true时  变量reset就被重置为这个参数（即true） 因此i会等于-1  下一轮循环就会从-1 开始递增</span></span><br><span class="line"><span class="comment">// next方法的参数代表上一个yield表达式的返回值  只有在下一次调用next方法时才会生效</span></span><br></pre></td></tr></table></figure>
<h3 id="for…of循环"><a class="header-anchor" href="#for…of循环">¶</a>for…of循环</h3>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> *<span class="title">foo</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">    <span class="keyword">yield</span> <span class="number">1</span>; </span><br><span class="line">    <span class="keyword">yield</span> <span class="number">2</span>; </span><br><span class="line">    <span class="keyword">yield</span> <span class="number">3</span>; </span><br><span class="line">    <span class="keyword">yield</span> <span class="number">4</span>; </span><br><span class="line">    <span class="keyword">yield</span> <span class="number">5</span>; </span><br><span class="line">    <span class="keyword">return</span> <span class="number">6</span>; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> v <span class="keyword">of</span> foo()) &#123; </span><br><span class="line">    <span class="built_in">console</span>.log(v); </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 1 2 3 4 5</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 一旦next方法返回对象的done属性为true  for...of循环就会终止  且不包含该对象</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用generator函数给对象加上接口</span></span><br><span class="line"><span class="keyword">let</span> jane = &#123; <span class="attr">first</span>: <span class="string">'Jane'</span>, <span class="attr">last</span>: <span class="string">'Doe'</span> &#125;;</span><br><span class="line"><span class="comment">// 方法一</span></span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">objectEntries</span>(<span class="params">obj</span>) </span>&#123; </span><br><span class="line">    <span class="keyword">let</span> propKeys = <span class="built_in">Reflect</span>.ownKeys(obj); </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> propKey <span class="keyword">of</span> propKeys) &#123; </span><br><span class="line">        <span class="keyword">yield</span> [propKey, obj[propKey]]; </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [key, value] <span class="keyword">of</span> objectEntries(jane)) &#123; </span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;key&#125;</span>: <span class="subst">$&#123;value&#125;</span>`</span>); </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// first: Jane </span></span><br><span class="line"><span class="comment">// last: Doe</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法二</span></span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">objectEntries</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">    <span class="keyword">let</span> propKeys = <span class="built_in">Object</span>.keys(<span class="keyword">this</span>); </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> propKey <span class="keyword">of</span> propKeys) &#123; </span><br><span class="line">        <span class="keyword">yield</span> [propKey, <span class="keyword">this</span>[propKey]]; </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line">jane[<span class="built_in">Symbol</span>.iterator] = objectEntries; </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [key, value] <span class="keyword">of</span> jane) &#123; </span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;key&#125;</span>: <span class="subst">$&#123;value&#125;</span>`</span>); </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// first: Jane </span></span><br><span class="line"><span class="comment">// last: Doe</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 其他遍历</span></span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">numbers</span> (<span class="params"></span>) </span>&#123; </span><br><span class="line">    <span class="keyword">yield</span> <span class="number">1</span> </span><br><span class="line">    <span class="keyword">yield</span> <span class="number">2</span> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">3</span> </span><br><span class="line">    <span class="keyword">yield</span> <span class="number">4</span> </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 扩展运算符 </span></span><br><span class="line">[...numbers()] <span class="comment">// [1, 2] </span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Array.from 方法 </span></span><br><span class="line"><span class="built_in">Array</span>.from(numbers()) <span class="comment">// [1, 2] </span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 解构赋值 </span></span><br><span class="line"><span class="keyword">let</span> [x, y] = numbers(); x <span class="comment">// 1 y // 2 </span></span><br><span class="line"></span><br><span class="line"><span class="comment">// for...of 循环 </span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> n <span class="keyword">of</span> numbers()) &#123; </span><br><span class="line">    <span class="built_in">console</span>.log(n) </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 1 // 2</span></span><br></pre></td></tr></table></figure>
<h3 id="throw"><a class="header-anchor" href="#throw">¶</a>throw</h3>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// generator函数返回的遍历器对象 都有一个throw方法  可以在函数外抛出错误  然后在generator函数体内捕获</span></span><br><span class="line"><span class="keyword">var</span> g = <span class="function"><span class="keyword">function</span>* (<span class="params"></span>) </span>&#123; </span><br><span class="line">    <span class="keyword">try</span> &#123; </span><br><span class="line">        <span class="keyword">yield</span>; </span><br><span class="line">    &#125; <span class="keyword">catch</span> (e) &#123; </span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'内部捕获'</span>, e); </span><br><span class="line">    &#125; </span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> i = g(); </span><br><span class="line">i.next(); </span><br><span class="line"><span class="keyword">try</span> &#123; </span><br><span class="line">    i.throw(<span class="string">'a'</span>); </span><br><span class="line">    i.throw(<span class="string">'b'</span>); </span><br><span class="line">&#125; <span class="keyword">catch</span> (e) &#123; </span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'外部捕获'</span>, e); </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 内部捕获 a </span></span><br><span class="line"><span class="comment">// 外部捕获 b</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// throw方法</span></span><br><span class="line"><span class="keyword">var</span> g = <span class="function"><span class="keyword">function</span>* (<span class="params"></span>) </span>&#123; </span><br><span class="line">    <span class="keyword">try</span> &#123; </span><br><span class="line">        <span class="keyword">yield</span>; </span><br><span class="line">    &#125; <span class="keyword">catch</span> (e) &#123; </span><br><span class="line">        <span class="built_in">console</span>.log(e); </span><br><span class="line">    &#125; </span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> i = g(); </span><br><span class="line">i.next(); </span><br><span class="line">i.throw(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'出错了！'</span>)); </span><br><span class="line"><span class="comment">// Error: 出错了！(…)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// throw方法被捕获后  会自动执行一次next方法</span></span><br><span class="line"><span class="comment">// 只有generator函数内部部署了try...catch代码块  那么遍历器的throw方法抛出的错误 不影响下一次遍历</span></span><br></pre></td></tr></table></figure>
<h3 id="return"><a class="header-anchor" href="#return">¶</a>return</h3>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 可以返回给定的值  并且终结遍历generator函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">gen</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">    <span class="keyword">yield</span> <span class="number">1</span>; </span><br><span class="line">    <span class="keyword">yield</span> <span class="number">2</span>; </span><br><span class="line">    <span class="keyword">yield</span> <span class="number">3</span>; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> g = gen(); </span><br><span class="line">g.next() <span class="comment">// &#123; value: 1, done: false &#125; </span></span><br><span class="line">g.return(<span class="string">'foo'</span>) <span class="comment">// &#123; value: "foo", done: true &#125;  如果return方法不传递参数  value属性值为undefined</span></span><br><span class="line">g.next() <span class="comment">// &#123; value: undefined, done: true &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果 Generator 函数内部有try...finally代码块，那么 return 方法 会推迟到 finally 代码块执行完再执行</span></span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">numbers</span> (<span class="params"></span>) </span>&#123; </span><br><span class="line">    <span class="keyword">yield</span> <span class="number">1</span>; </span><br><span class="line">    <span class="keyword">try</span> &#123; </span><br><span class="line">        <span class="keyword">yield</span> <span class="number">2</span>; </span><br><span class="line">        <span class="keyword">yield</span> <span class="number">3</span>; </span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123; </span><br><span class="line">        <span class="keyword">yield</span> <span class="number">4</span>; </span><br><span class="line">        <span class="keyword">yield</span> <span class="number">5</span>; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">6</span>; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> g = numbers(); </span><br><span class="line">g.next() <span class="comment">// &#123; value: 1, done: false &#125; </span></span><br><span class="line">g.next() <span class="comment">// &#123; value: 2, done: false &#125; </span></span><br><span class="line">g.return(<span class="number">7</span>) <span class="comment">// &#123; value: 4, done: false &#125; </span></span><br><span class="line">g.next() <span class="comment">// &#123; value: 5, done: false &#125; </span></span><br><span class="line">g.next() <span class="comment">// &#123; value: 7, done: true &#125;</span></span><br><span class="line"><span class="comment">// 当调用return方法后  就开始执行finally代码块  然后等finally执行完  再执行return方法</span></span><br></pre></td></tr></table></figure>
<h3 id="yield-表达式"><a class="header-anchor" href="#yield-表达式">¶</a>yield*表达式</h3>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果在generator函数内部  调用另一个generator函数  默认情况下是没效果的</span></span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">foo</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">    <span class="keyword">yield</span> <span class="string">'a'</span>; </span><br><span class="line">    <span class="keyword">yield</span> <span class="string">'b'</span>; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">bar</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">    <span class="keyword">yield</span> <span class="string">'x'</span>; </span><br><span class="line">    foo(); </span><br><span class="line">    <span class="keyword">yield</span> <span class="string">'y'</span>; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> v <span class="keyword">of</span> bar())&#123; </span><br><span class="line">    <span class="built_in">console</span>.log(v); </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// "x" </span></span><br><span class="line"><span class="comment">// "y"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用yield*表达式  可以在一个generator函数里执行另一个generator函数</span></span><br><span class="line">	    <span class="function"><span class="keyword">function</span>* <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">yield</span> <span class="string">'x'</span>;</span><br><span class="line">            <span class="keyword">yield</span>* foo();</span><br><span class="line">            <span class="keyword">yield</span> <span class="string">'y'</span>;</span><br><span class="line">        &#125; <span class="comment">// 等同于 </span></span><br><span class="line">        <span class="function"><span class="keyword">function</span>* <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">yield</span> <span class="string">'x'</span>;</span><br><span class="line">            <span class="keyword">yield</span> <span class="string">'a'</span>;</span><br><span class="line">            <span class="keyword">yield</span> <span class="string">'b'</span>;</span><br><span class="line">            <span class="keyword">yield</span> <span class="string">'y'</span>;</span><br><span class="line">        &#125; <span class="comment">// 等同于 </span></span><br><span class="line">        <span class="function"><span class="keyword">function</span>* <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">yield</span> <span class="string">'x'</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">let</span> v <span class="keyword">of</span> foo()) &#123;</span><br><span class="line">                <span class="keyword">yield</span> v;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">yield</span> <span class="string">'y'</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> v <span class="keyword">of</span> bar()) &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(v);</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="comment">// "x" </span></span><br><span class="line">        <span class="comment">// "a" </span></span><br><span class="line">        <span class="comment">// "b" </span></span><br><span class="line">        <span class="comment">// "y</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 另一个例子</span></span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">inner</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">    <span class="keyword">yield</span> <span class="string">'hello!'</span>; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">outer1</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">    <span class="keyword">yield</span> <span class="string">'open'</span>; </span><br><span class="line">    <span class="keyword">yield</span> inner(); </span><br><span class="line">    <span class="keyword">yield</span> <span class="string">'close'</span>; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> gen = outer1() </span><br><span class="line">gen.next().value <span class="comment">// "open" </span></span><br><span class="line">gen.next().value <span class="comment">// 返回一个遍历器对象 </span></span><br><span class="line">gen.next().value <span class="comment">// "close" </span></span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">outer2</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">    <span class="keyword">yield</span> <span class="string">'open'</span> </span><br><span class="line">    <span class="keyword">yield</span>* inner() </span><br><span class="line">    <span class="keyword">yield</span> <span class="string">'close'</span> </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> gen = outer2() </span><br><span class="line">gen.next().value <span class="comment">// "open" </span></span><br><span class="line">gen.next().value <span class="comment">// "hello!" 返回该遍历器对象的内部值</span></span><br><span class="line">gen.next().value <span class="comment">// "close"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// yield*后面的generator函数（没有return语句时）等同于在函数内部部署了一个for...of循环</span></span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">concat</span>(<span class="params">iter1, iter2</span>) </span>&#123; </span><br><span class="line">    <span class="keyword">yield</span>* iter1; </span><br><span class="line">    <span class="keyword">yield</span>* iter2; </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 等同于 </span></span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">concat</span>(<span class="params">iter1, iter2</span>) </span>&#123; </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> value <span class="keyword">of</span> iter1) &#123; </span><br><span class="line">        <span class="keyword">yield</span> value; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> value <span class="keyword">of</span> iter2) &#123; </span><br><span class="line">        <span class="keyword">yield</span> value; </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果yield*后面跟着一个数组  会遍历数组成员</span></span><br><span class="line"><span class="comment">// 任何数据结构只要有Iterator接口  就可以被yield*遍历</span></span><br></pre></td></tr></table></figure>
<h3 id="作为对象属性的generator函数"><a class="header-anchor" href="#作为对象属性的generator函数">¶</a>作为对象属性的generator函数</h3>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果一个对象的属性时generator函数  可以简写成下面的形式</span></span><br><span class="line"><span class="keyword">let</span> obj = &#123; </span><br><span class="line">    * myGeneratorMethod() &#123;</span><br><span class="line">        ··· </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 等价写法</span></span><br><span class="line"><span class="keyword">let</span> obj = &#123; </span><br><span class="line">    myGeneratorMethod: <span class="function"><span class="keyword">function</span>* (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="comment">// ··· </span></span><br><span class="line">    &#125; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="generator函数的this"><a class="header-anchor" href="#generator函数的this">¶</a>generator函数的this</h3>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// generator函数总是返回一个遍历器  这个遍历器时generator函数的实例 也继承了generator函数的prototype对象上的方法</span></span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">g</span>(<span class="params"></span>) </span>&#123;&#125; </span><br><span class="line">    g.prototype.hello = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; </span><br><span class="line">    <span class="keyword">return</span> <span class="string">'hi!'</span>; </span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> obj = g(); </span><br><span class="line">obj <span class="keyword">instanceof</span> g <span class="comment">// true </span></span><br><span class="line">obj.hello() <span class="comment">// 'hi!</span></span><br><span class="line"><span class="comment">// 如果把g当作普通的构造函数 并不会生效 因为g返回的总是遍历器对象 而不是this对象</span></span><br><span class="line"><span class="comment">// generator函数不能跟new命令一起用 会报错</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以通过call方法绑定generator函数内部的this  </span></span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">F</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">    <span class="keyword">this</span>.a = <span class="number">1</span>; </span><br><span class="line">    <span class="keyword">yield</span> <span class="keyword">this</span>.b = <span class="number">2</span>; </span><br><span class="line">    <span class="keyword">yield</span> <span class="keyword">this</span>.c = <span class="number">3</span>; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;&#125;; </span><br><span class="line"><span class="keyword">var</span> f = F.call(obj); </span><br><span class="line">f.next(); <span class="comment">// Object &#123;value: 2, done: false&#125; </span></span><br><span class="line">f.next(); <span class="comment">// Object &#123;value: 3, done: false&#125; </span></span><br><span class="line">f.next(); <span class="comment">// Object &#123;value: undefined, done: true&#125; </span></span><br><span class="line">obj.a <span class="comment">// 1 </span></span><br><span class="line">obj.b <span class="comment">// 2 </span></span><br><span class="line">obj.c <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 将obj换成F.prototype</span></span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">F</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">    <span class="keyword">this</span>.a = <span class="number">1</span>; </span><br><span class="line">    <span class="keyword">yield</span> <span class="keyword">this</span>.b = <span class="number">2</span>; </span><br><span class="line">    <span class="keyword">yield</span> <span class="keyword">this</span>.c = <span class="number">3</span>; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> f = F.call(F.prototype); </span><br><span class="line">f.next(); <span class="comment">// Object &#123;value: 2, done: false&#125; </span></span><br><span class="line">f.next(); <span class="comment">// Object &#123;value: 3, done: false&#125; </span></span><br><span class="line">f.next(); <span class="comment">// Object &#123;value: undefined, done: true&#125; </span></span><br><span class="line">f.a <span class="comment">// 1 </span></span><br><span class="line">f.b <span class="comment">// 2 </span></span><br><span class="line">f.c <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 再将F改成构造函数  就可以执行new命令</span></span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">gen</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">    <span class="keyword">this</span>.a = <span class="number">1</span>; </span><br><span class="line">    <span class="keyword">yield</span> <span class="keyword">this</span>.b = <span class="number">2</span>; </span><br><span class="line">    <span class="keyword">yield</span> <span class="keyword">this</span>.c = <span class="number">3</span>; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">    <span class="keyword">return</span> gen.call(gen.prototype); </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> f = <span class="keyword">new</span> F(); </span><br><span class="line">f.next(); <span class="comment">// Object &#123;value: 2, done: false&#125; </span></span><br><span class="line">f.next(); <span class="comment">// Object &#123;value: 3, done: false&#125; </span></span><br><span class="line">f.next(); <span class="comment">// Object &#123;value: undefined, done: true&#125; </span></span><br><span class="line">f.a <span class="comment">// 1 </span></span><br><span class="line">f.b <span class="comment">// 2 </span></span><br><span class="line">f.c <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>




  <article id="post-13、Iterator和for-of循环" class="h-entry post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time class="dt-published" datetime="2020-07-18T13:51:35.000Z"><a href="/2020/07/18/13、Iterator和for-of循环/">2020-07-18</a></time>
      
      
  
    <h1 class="title"><a href="/2020/07/18/13、Iterator和for-of循环/">Iterator和for...of循环</a></h1>
  

    </header>
    <div class="e-content entry" itemprop="articleBody">
      
        <p>[TOC]</p>
<h2 id="Iterator和for…of循环"><a class="header-anchor" href="#Iterator和for…of循环">¶</a>Iterator和for…of循环</h2>
<h3 id="Iterator"><a class="header-anchor" href="#Iterator">¶</a>Iterator</h3>
<ul>
<li>为各种不同的数据结构提供统一的访问机制</li>
<li>任何数据结构只要部署<code>Iterator</code>接口  就可以完成遍历操作（依次处理该数据结构的所有成员）</li>
<li>作用（1）为各种数据结构提供一个统一的、简便的访问接口</li>
<li>（2）使数据结构的成员能够按某种次序排列</li>
<li>（3）<code>for...of</code>循环</li>
</ul>
<h4 id="遍历过程"><a class="header-anchor" href="#遍历过程">¶</a>遍历过程</h4>
<ol>
<li>创建一个指针对象  指向当前数据结构的起始位（遍历器对象本质上就是一个指针对象）</li>
<li>第一次调用指针对象的<code>next</code>方法  可以将指针指向数据结构的第一个成员</li>
<li>第二次调用指针对象的<code>next</code>方法 指针指向第二个成员</li>
<li>不断调用指针对象的<code>next</code>方法  直到它指向数据结构的结束位置</li>
</ol>
<ul>
<li>
<p>每一次调用<code>next</code>方法  都会返回数据结构当前成员的信息（返回一个包含<code>value</code>和<code>done</code>两个属性的对象）</p>
</li>
<li>
<p><code>value</code>属性使当前成员的值  <code>done</code>属性是一个布尔值  表示遍历是否结束</p>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 一个模拟遍历器的函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">makeIterator</span>(<span class="params">array</span>) </span>&#123; </span><br><span class="line">    <span class="keyword">var</span> nextIndex = <span class="number">0</span>; </span><br><span class="line">    <span class="keyword">return</span> &#123; </span><br><span class="line">        next: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">            <span class="keyword">return</span> nextIndex &lt; array.length ? </span><br><span class="line">                &#123;<span class="attr">value</span>: array[nextIndex++], <span class="attr">done</span>: <span class="literal">false</span>&#125; : </span><br><span class="line">            	&#123;<span class="attr">value</span>: <span class="literal">undefined</span>, <span class="attr">done</span>: <span class="literal">true</span>&#125;</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>遍历器与它所遍历的那个数据结构实际上是分开的   所有可以用遍历器模拟出数据结构</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用typescript的写法  遍历器接口(iterable) 指针对象(iterator) </span></span><br><span class="line">interface Iterable &#123; </span><br><span class="line">    [<span class="built_in">Symbol</span>.iterator]() : Iterator </span><br><span class="line">&#125;</span><br><span class="line">interface Iterator &#123;</span><br><span class="line">    next(value?: any) : IterationResult, </span><br><span class="line">&#125;        </span><br><span class="line">interface IterationResult &#123; </span><br><span class="line">    value: any, </span><br><span class="line">    done: boolean</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="默认Iterator接口"><a class="header-anchor" href="#默认Iterator接口">¶</a>默认Iterator接口</h4>
<ul>
<li>
<p>当使用<code>for...of</code>循环遍历某种数据结构时  该循环会自动寻找<code>Iterator</code>接口</p>
</li>
<li>
<p>一种数据只要部署了<code>Iterator</code>接口  就称这种数据结构是可遍历的</p>
</li>
<li>
<p>默认的<code>Iterator</code>接口部署在<code>Symbol.iterator</code>属性（本身是一个函数  执行函数就好返回一个遍历器）</p>
</li>
<li>
<p>属性名<code>Symbol.iterator</code>是一个表达式  返回<code>Symbol</code> 对象的 <code>iterator</code> 属性</p>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123; </span><br><span class="line">    [<span class="built_in">Symbol</span>.iterator] : <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; </span><br><span class="line">        <span class="keyword">return</span> &#123; </span><br><span class="line">            next: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; </span><br><span class="line">                <span class="keyword">return</span> &#123; </span><br><span class="line">                    value: <span class="number">1</span>, </span><br><span class="line">                    done: <span class="literal">true</span> </span><br><span class="line">                &#125; </span><br><span class="line">            &#125; </span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// es6中有些数据结构原生具备Iterator接口（不用任何处理就可以被for...of循环遍历）</span></span><br><span class="line"><span class="comment">// Array Map Set String TypedArray 函数的arguments对象 NodeList对象</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 为对象添加Iterator接口</span></span><br><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">    data: [<span class="string">'hello'</span>, <span class="string">'world'</span>],</span><br><span class="line">    [<span class="built_in">Symbol</span>.iterator]() &#123;</span><br><span class="line">        <span class="keyword">const</span> self = <span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">let</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            next() &#123;</span><br><span class="line">                <span class="keyword">if</span> (index &lt; self.data.length) &#123;</span><br><span class="line">                    <span class="keyword">return</span> &#123;</span><br><span class="line">                        value: self.data[index++],</span><br><span class="line">                        done: <span class="literal">false</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> &#123;</span><br><span class="line">                        value: <span class="literal">undefined</span>,</span><br><span class="line">                        done: <span class="literal">true</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对于类数组对象（存在数值键名和length属性）可以引用数组的Iterator接口来部署</span></span><br><span class="line">NodeList.prototype[<span class="built_in">Symbol</span>.iterator] = <span class="built_in">Array</span>.prototype[<span class="built_in">Symbol</span>.iterator]; </span><br><span class="line"><span class="comment">// 或者 </span></span><br><span class="line">NodeList.prototype[<span class="built_in">Symbol</span>.iterator] = [][<span class="built_in">Symbol</span>.iterator]</span><br><span class="line">[...document.querySelectorAll(<span class="string">'div'</span>)] </span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果Symbol.iterator 方法对应的不是遍历器生成函数（即会返回一 个遍历器对象）会报错</span></span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>因为对象属性的遍历顺序是不确定的  所有没有部署接口  Map部署了接口  对象实际上被当作Map结构使用</p>
</li>
<li>
<p>在下列几个场合中会默认调用<code>Iterator</code>接口</p>
</li>
</ul>
<ol>
<li>解构赋值（对数组和set结构进行解构赋值时）</li>
<li>扩展运算符（任何部署了Iterator接口的数据结构 可以通过扩展运算符转成数组）</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 3. yield* 可遍历的结构 </span></span><br><span class="line"><span class="keyword">let</span> generator = <span class="function"><span class="keyword">function</span>* (<span class="params"></span>) </span>&#123; </span><br><span class="line">    <span class="keyword">yield</span> <span class="number">1</span>; </span><br><span class="line">    <span class="keyword">yield</span>* [<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]; </span><br><span class="line">    <span class="keyword">yield</span> <span class="number">5</span>; </span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> iterator = generator(); </span><br><span class="line">iterator.next() <span class="comment">// &#123; value: 1, done: false &#125; </span></span><br><span class="line">iterator.next() <span class="comment">// &#123; value: 2, done: false &#125; </span></span><br><span class="line">iterator.next() <span class="comment">// &#123; value: 3, done: false &#125; </span></span><br><span class="line">iterator.next() <span class="comment">// &#123; value: 4, done: false &#125; </span></span><br><span class="line">iterator.next() <span class="comment">// &#123; value: 5, done: false &#125; </span></span><br><span class="line">iterator.next() <span class="comment">// &#123; value: undefined, done: true &#125;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 由于数组的遍历会调用遍历器接口  所有任何接收数组作为参数的场合都调用了遍历器接口</span></span><br><span class="line"><span class="comment">// 例如  for...of  Aarray.from()  Map()  Set()  WeakMap() WeakSet() Promise.all() Promise.race()</span></span><br></pre></td></tr></table></figure>
<h5 id="字符串的Iterator接口"><a class="header-anchor" href="#字符串的Iterator接口">¶</a>字符串的Iterator接口</h5>
<ul>
<li>
<p>字符串是一个类似数组的对象  也原生具有Iterator接口</p>
</li>
<li>
<p>可以通过覆盖原生的<code>Symbol.iterator</code>方法  达到修改遍历器行为的目的</p>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">"hi"</span>); </span><br><span class="line">[...str] <span class="comment">// ["h", "i"] </span></span><br><span class="line"></span><br><span class="line">str[<span class="built_in">Symbol</span>.iterator] = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123; </span><br><span class="line">        next: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>._first) &#123;</span><br><span class="line">                <span class="keyword">this</span>._first = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">return</span> &#123; </span><br><span class="line">                    value: <span class="string">"bye"</span>, </span><br><span class="line">                    done: <span class="literal">false</span> </span><br><span class="line">                &#125; </span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; </span><br><span class="line">                <span class="keyword">return</span> &#123; </span><br><span class="line">                    done: <span class="literal">true</span> </span><br><span class="line">                &#125; </span><br><span class="line">            &#125; </span><br><span class="line">        &#125;,</span><br><span class="line">        _first: <span class="literal">true</span> </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line">[...str] <span class="comment">// ["bye"] str // "hi"</span></span><br></pre></td></tr></table></figure>
<h5 id="Iterator接口与Generator函数"><a class="header-anchor" href="#Iterator接口与Generator函数">¶</a>Iterator接口与Generator函数</h5>
<ul>
<li><code>Symbol.iterator</code>方法的最简单实现是使用<code>Generator</code>函数</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myIterable = &#123;&#125;; </span><br><span class="line">myIterable[<span class="built_in">Symbol</span>.iterator] = <span class="function"><span class="keyword">function</span>* (<span class="params"></span>) </span>&#123; </span><br><span class="line">    <span class="keyword">yield</span> <span class="number">1</span>; </span><br><span class="line">    <span class="keyword">yield</span> <span class="number">2</span>; </span><br><span class="line">    <span class="keyword">yield</span> <span class="number">3</span>; </span><br><span class="line">&#125;;</span><br><span class="line">[...myIterable] <span class="comment">// [1, 2, 3] </span></span><br><span class="line"><span class="comment">// 或者采用下面的简洁写法 </span></span><br><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">    * [<span class="built_in">Symbol</span>.iterator]() &#123; </span><br><span class="line">        <span class="keyword">yield</span> <span class="string">'hello'</span>; </span><br><span class="line">        <span class="keyword">yield</span> <span class="string">'world'</span>; </span><br><span class="line">    &#125; </span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> x <span class="keyword">of</span> obj) &#123; </span><br><span class="line">    <span class="built_in">console</span>.log(x); </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// hello // world</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 上面代码中， Symbol.iterator 方法几乎不用部署任何代码，只要用 yield命令给出每一步的返回值即可</span></span><br></pre></td></tr></table></figure>
<h5 id="遍历器对象的return-throw"><a class="header-anchor" href="#遍历器对象的return-throw">¶</a>遍历器对象的return()  throw()</h5>
<ul>
<li>遍历器对象还具有return方法和throw方法  next方法是必须部署的  return方法和throw方法可以选择</li>
</ul>
<h6 id="return"><a class="header-anchor" href="#return">¶</a>return</h6>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果for...of 循环提前退出（通常是因为出错或有break或continue语句）就会调用return方法  如果一个对象在完成遍历前  需要清理或释放资源  就可以部署return方法</span></span><br><span class="line"><span class="comment">// return方法必须返回一个对象</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">readLinesSync</span>(<span class="params">file</span>) </span>&#123; </span><br><span class="line">    <span class="keyword">return</span> &#123; </span><br><span class="line">        next() &#123; </span><br><span class="line">            <span class="keyword">return</span> &#123; </span><br><span class="line">                done: <span class="literal">false</span> </span><br><span class="line">            &#125;; </span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="keyword">return</span>() &#123;</span><br><span class="line">            file.close();</span><br><span class="line">            <span class="keyword">return</span> &#123; </span><br><span class="line">                done: <span class="literal">true</span> </span><br><span class="line">            &#125;; </span><br><span class="line">        &#125;, </span><br><span class="line">    &#125;; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 下列的三种情况都会触发return方法</span></span><br><span class="line"><span class="comment">// 情况一 for </span></span><br><span class="line">(<span class="keyword">let</span> line <span class="keyword">of</span> readLinesSync(fileName)) &#123; </span><br><span class="line">    <span class="built_in">console</span>.log(line); </span><br><span class="line">    <span class="keyword">break</span>;   <span class="comment">// 在执行完break前的语句 就会执行return方法  关闭这个文件</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 情况二 </span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> line <span class="keyword">of</span> readLinesSync(fileName)) &#123; </span><br><span class="line">    <span class="built_in">console</span>.log(line); </span><br><span class="line">    <span class="keyword">continue</span>;  <span class="comment">// 在执行所有代码后  执行return方法  关闭文件</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 情况三 </span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> line <span class="keyword">of</span> readLinesSync(fileName)) &#123; </span><br><span class="line">    <span class="built_in">console</span>.log(line); </span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>();  <span class="comment">// 会执行完return方法后  再抛出错误</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="for…of循环"><a class="header-anchor" href="#for…of循环">¶</a>for…of循环</h3>
<ul>
<li>一个数据结构只要部署了 <code>Symbol.iterator</code> 属性就被视为具有<code>iterator</code>接口，就可以用 for…of 循环遍历它的成员。</li>
<li>也就是说   <code>for...of</code> 循环内部调用的是数据结构的 <code>Symbol.iterator</code> 方法</li>
<li><code>for...of</code> 循环可以使用的范围包括数组、<code>Set</code> 和 <code>Map</code> 结构、某些类似 数组的对象（比如 <code>arguments</code> 对象、<code>DOM NodeList</code> 对象）、后文的<code>Generator</code> 对象，以及字符串</li>
</ul>
<h4 id="数组"><a class="header-anchor" href="#数组">¶</a>数组</h4>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="string">'red'</span>, <span class="string">'green'</span>, <span class="string">'blue'</span>]; </span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> v <span class="keyword">of</span> arr) &#123; </span><br><span class="line">    <span class="built_in">console</span>.log(v); <span class="comment">// red green blue </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 空对象部署了数组得Symbol.iterator属性  产生了一样的结果</span></span><br><span class="line"><span class="keyword">const</span> obj = &#123;&#125;; </span><br><span class="line">obj[<span class="built_in">Symbol</span>.iterator] = arr[<span class="built_in">Symbol</span>.iterator].bind(arr); </span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> v <span class="keyword">of</span> obj) &#123; </span><br><span class="line">    <span class="built_in">console</span>.log(v); <span class="comment">// red green blue </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// for...of循环可以替代数组实例得forEach方法</span></span><br><span class="line"><span class="comment">// for...in循环只能获得对象的键名  不能直接获取键值  for...of循环允许遍历获得键值</span></span><br></pre></td></tr></table></figure>
<h4 id="set和map结构"><a class="header-anchor" href="#set和map结构">¶</a>set和map结构</h4>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> engines = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="string">"Gecko"</span>, <span class="string">"Trident"</span>, <span class="string">"Webkit"</span>, <span class="string">"Webkit"</span>]); </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> e <span class="keyword">of</span> engines) &#123; </span><br><span class="line">    <span class="built_in">console</span>.log(e); </span><br><span class="line">&#125; <span class="comment">// Gecko // Trident // Webkit </span></span><br><span class="line"><span class="keyword">var</span> es6 = <span class="keyword">new</span> <span class="built_in">Map</span>(); </span><br><span class="line">es6.set(<span class="string">"edition"</span>, <span class="number">6</span>); </span><br><span class="line">es6.set(<span class="string">"committee"</span>, <span class="string">"TC39"</span>); </span><br><span class="line">es6.set(<span class="string">"standard"</span>, <span class="string">"ECMA-262"</span>); </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> [name, value] <span class="keyword">of</span> es6) &#123; </span><br><span class="line">    <span class="built_in">console</span>.log(name + <span class="string">": "</span> + value); </span><br><span class="line">&#125; <span class="comment">// edition: 6 // committee: TC39 // standard: ECMA-262</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历的顺序是按照各个成员被添加进数据结构的顺序</span></span><br><span class="line"><span class="comment">// set结构遍历时 返回的是一个值  map结构遍历时  返回的是一个数组  数组的两个成员分别是键名和键值</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>().set(<span class="string">'a'</span>, <span class="number">1</span>).set(<span class="string">'b'</span>, <span class="number">2</span>); </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> pair <span class="keyword">of</span> map) &#123; </span><br><span class="line">    <span class="built_in">console</span>.log(pair); </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ['a', 1] </span></span><br><span class="line"><span class="comment">// ['b', 2] </span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [key, value] <span class="keyword">of</span> map) &#123; </span><br><span class="line">    <span class="built_in">console</span>.log(key + <span class="string">' : '</span> + value); </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// a : 1 </span></span><br><span class="line"><span class="comment">// b : 2</span></span><br></pre></td></tr></table></figure>
<h4 id="计算生成的数据结构"><a class="header-anchor" href="#计算生成的数据结构">¶</a>计算生成的数据结构</h4>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 有些数据结构是在现有数据结构的基础上计算生成的  es6在数组 set map都部署了三个方法调用后都返回遍历器对象</span></span><br><span class="line"><span class="comment">// entries() 返回一个遍历器对象，用来遍历 [键名, 键值] 组成的 数组。对于数组，键名就是索引值；对于 Set，键名与键值相同  Map 结构的 Iterator 接口，默认就是调用 entries 方法。</span></span><br><span class="line"><span class="comment">// keys() 返回一个遍历器对象，用来遍历所有的键名</span></span><br><span class="line"><span class="comment">// values() 返回一个遍历器对象，用来遍历所有的键值</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 三个方法调用后生成遍历器对象  所遍历的都是计算生成的数据结构</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> arr = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>]; </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> pair <span class="keyword">of</span> arr.entries()) &#123; </span><br><span class="line">    <span class="built_in">console</span>.log(pair); </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// [0, 'a'] </span></span><br><span class="line"><span class="comment">// [1, 'b'] </span></span><br><span class="line"><span class="comment">// [2, 'c']</span></span><br></pre></td></tr></table></figure>
<h4 id="类数组对象"><a class="header-anchor" href="#类数组对象">¶</a>类数组对象</h4>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 字符串  for...of循环可以正确识别32位字符</span></span><br><span class="line"><span class="keyword">let</span> str = <span class="string">"hello"</span>; </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> s <span class="keyword">of</span> str) &#123; </span><br><span class="line">    <span class="built_in">console</span>.log(s); <span class="comment">// h e l l o </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// DOM NodeList对象 </span></span><br><span class="line"><span class="keyword">let</span> paras = <span class="built_in">document</span>.querySelectorAll(<span class="string">"p"</span>); </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> p <span class="keyword">of</span> paras) &#123; </span><br><span class="line">    p.classList.add(<span class="string">"test"</span>); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// arguments对象 </span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">printArgs</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> x <span class="keyword">of</span> <span class="built_in">arguments</span>) &#123; </span><br><span class="line">        <span class="built_in">console</span>.log(x); </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line">printArgs(<span class="string">'a'</span>, <span class="string">'b'</span>); <span class="comment">// 'a' // 'b'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以用Array.from方法转为数组的方法解决类数组对象没有接口的问题</span></span><br><span class="line"><span class="keyword">let</span> arrayLike = &#123; <span class="attr">length</span>: <span class="number">2</span>, <span class="number">0</span>: <span class="string">'a'</span>, <span class="number">1</span>: <span class="string">'b'</span> &#125;; </span><br><span class="line"><span class="comment">// 报错 </span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> x <span class="keyword">of</span> arrayLike) &#123; </span><br><span class="line">    <span class="built_in">console</span>.log(x); </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 正确 </span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> x <span class="keyword">of</span> <span class="built_in">Array</span>.from(arrayLike)) &#123; </span><br><span class="line">    <span class="built_in">console</span>.log(x); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="对像"><a class="header-anchor" href="#对像">¶</a>对像</h4>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 对于普通的对象  for...in循环可以遍历键名  for...of循环会报错</span></span><br><span class="line"><span class="comment">// 一种解决办法是使用Object.keys方法将对象的键名生成一个数组  然后遍历这个数组</span></span><br><span class="line"><span class="comment">// 另一个方法是使用Generator函数将对象重新包装</span></span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">entries</span>(<span class="params">obj</span>) </span>&#123; </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">of</span> <span class="built_in">Object</span>.keys(obj)) &#123; </span><br><span class="line">        <span class="keyword">yield</span> [key, obj[key]]; </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [key, value] <span class="keyword">of</span> entries(obj)) &#123; </span><br><span class="line">    <span class="built_in">console</span>.log(key, <span class="string">'-&gt;'</span>, value); </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// a -&gt; 1 </span></span><br><span class="line"><span class="comment">// b -&gt; 2 </span></span><br><span class="line"><span class="comment">// c -&gt; 3</span></span><br></pre></td></tr></table></figure>
<h4 id="与其他遍历方法比较"><a class="header-anchor" href="#与其他遍历方法比较">¶</a>与其他遍历方法比较</h4>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// for循环</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> index = <span class="number">0</span>; index &lt; myArray.length; index++) &#123; 							<span class="built_in">console</span>.log(myArray[index]); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 数组的forEach  问题：无法中途跳出forEach循环  break或return不能奏效</span></span><br><span class="line">myArray.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123; </span><br><span class="line">    <span class="built_in">console</span>.log(value); </span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// for...in遍历键名</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> index <span class="keyword">in</span> myArray) &#123; </span><br><span class="line">    <span class="built_in">console</span>.log(myArray[index]); </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 问题：for...in 循环不仅遍历键名，还会遍历手动添加的其他键， 甚至包括原型链上的键</span></span><br><span class="line"><span class="comment">// 某些情况下  for...in循环会以任意顺序遍历键名</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// for...of</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> value <span class="keyword">of</span> myArray) &#123; </span><br><span class="line">    <span class="built_in">console</span>.log(value); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>





<nav id="pagination">
  
  
    <a href="/page/2/" class="alignright next">Next</a>
  
  <div class="clearfix"></div>
</nav></div></div>
    <aside id="sidebar" class="alignright">
  <div class="search">
  <form action="//google.com/search" method="get" accept-charset="utf-8">
    <input type="search" name="q" results="0" placeholder="Search">
    <input type="hidden" name="as_sitesearch" value="yoursite.com">
  </form>
</div>


  

  
<div class="widget tag">
  <h3 class="title">Tags</h3>
  <ul class="entry">
  
    <li><a href="/tags/JavaScript/">JavaScript</a><small>3</small></li>
  
    <li><a href="/tags/es6/">es6</a><small>11</small></li>
  
    <li><a href="/tags/git/">git</a><small>1</small></li>
  
  </ul>
</div>

</aside>
    <div class="clearfix"></div>
  </div>
  <footer id="footer" class="inner"><div class="alignleft">
  
  &copy; 2020 John Doe
  
</div>
<div class="clearfix"></div></footer>
  
<script src="/js/jquery-3.4.1.min.js"></script>


<script src="/js/jquery.imagesloaded.min.js"></script>


<script src="/js/gallery.js"></script>






<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">


<script src="/fancybox/jquery.fancybox.pack.js"></script>

<script type="text/javascript">
(function($){
  $('.fancybox').fancybox();
})(jQuery);
</script>

</body>
</html>

<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 4.2.1"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-Iterator和for-of循环" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/07/18/Iterator%E5%92%8Cfor-of%E5%BE%AA%E7%8E%AF/" class="article-date">
  <time datetime="2020-07-18T13:51:35.000Z" itemprop="datePublished">2020-07-18</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/07/18/Iterator%E5%92%8Cfor-of%E5%BE%AA%E7%8E%AF/">Iterator和for...of循环</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>[TOC]</p>
<h2 id="Iterator和for…of循环"><a class="header-anchor" href="#Iterator和for…of循环">¶</a>Iterator和for…of循环</h2>
<h3 id="Iterator"><a class="header-anchor" href="#Iterator">¶</a>Iterator</h3>
<ul>
<li>为各种不同的数据结构提供统一的访问机制</li>
<li>任何数据结构只要部署<code>Iterator</code>接口  就可以完成遍历操作（依次处理该数据结构的所有成员）</li>
<li>作用（1）为各种数据结构提供一个统一的、简便的访问接口</li>
<li>（2）使数据结构的成员能够按某种次序排列</li>
<li>（3）<code>for...of</code>循环</li>
</ul>
<h4 id="遍历过程"><a class="header-anchor" href="#遍历过程">¶</a>遍历过程</h4>
<ol>
<li>创建一个指针对象  指向当前数据结构的起始位（遍历器对象本质上就是一个指针对象）</li>
<li>第一次调用指针对象的<code>next</code>方法  可以将指针指向数据结构的第一个成员</li>
<li>第二次调用指针对象的<code>next</code>方法 指针指向第二个成员</li>
<li>不断调用指针对象的<code>next</code>方法  直到它指向数据结构的结束位置</li>
</ol>
<ul>
<li>
<p>每一次调用<code>next</code>方法  都会返回数据结构当前成员的信息（返回一个包含<code>value</code>和<code>done</code>两个属性的对象）</p>
</li>
<li>
<p><code>value</code>属性使当前成员的值  <code>done</code>属性是一个布尔值  表示遍历是否结束</p>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 一个模拟遍历器的函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">makeIterator</span>(<span class="params">array</span>) </span>&#123; </span><br><span class="line">    <span class="keyword">var</span> nextIndex = <span class="number">0</span>; </span><br><span class="line">    <span class="keyword">return</span> &#123; </span><br><span class="line">        next: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">            <span class="keyword">return</span> nextIndex &lt; array.length ? </span><br><span class="line">                &#123;<span class="attr">value</span>: array[nextIndex++], <span class="attr">done</span>: <span class="literal">false</span>&#125; : </span><br><span class="line">            	&#123;<span class="attr">value</span>: <span class="literal">undefined</span>, <span class="attr">done</span>: <span class="literal">true</span>&#125;</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>遍历器与它所遍历的那个数据结构实际上是分开的   所有可以用遍历器模拟出数据结构</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用typescript的写法  遍历器接口(iterable) 指针对象(iterator) </span></span><br><span class="line">interface Iterable &#123; </span><br><span class="line">    [<span class="built_in">Symbol</span>.iterator]() : Iterator </span><br><span class="line">&#125;</span><br><span class="line">interface Iterator &#123;</span><br><span class="line">    next(value?: any) : IterationResult, </span><br><span class="line">&#125;        </span><br><span class="line">interface IterationResult &#123; </span><br><span class="line">    value: any, </span><br><span class="line">    done: boolean</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="默认Iterator接口"><a class="header-anchor" href="#默认Iterator接口">¶</a>默认Iterator接口</h4>
<ul>
<li>
<p>当使用<code>for...of</code>循环遍历某种数据结构时  该循环会自动寻找<code>Iterator</code>接口</p>
</li>
<li>
<p>一种数据只要部署了<code>Iterator</code>接口  就称这种数据结构是可遍历的</p>
</li>
<li>
<p>默认的<code>Iterator</code>接口部署在<code>Symbol.iterator</code>属性（本身是一个函数  执行函数就好返回一个遍历器）</p>
</li>
<li>
<p>属性名<code>Symbol.iterator</code>是一个表达式  返回<code>Symbol</code> 对象的 <code>iterator</code> 属性</p>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123; </span><br><span class="line">    [<span class="built_in">Symbol</span>.iterator] : <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; </span><br><span class="line">        <span class="keyword">return</span> &#123; </span><br><span class="line">            next: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; </span><br><span class="line">                <span class="keyword">return</span> &#123; </span><br><span class="line">                    value: <span class="number">1</span>, </span><br><span class="line">                    done: <span class="literal">true</span> </span><br><span class="line">                &#125; </span><br><span class="line">            &#125; </span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// es6中有些数据结构原生具备Iterator接口（不用任何处理就可以被for...of循环遍历）</span></span><br><span class="line"><span class="comment">// Array Map Set String TypedArray 函数的arguments对象 NodeList对象</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 为对象添加Iterator接口</span></span><br><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">    data: [<span class="string">'hello'</span>, <span class="string">'world'</span>],</span><br><span class="line">    [<span class="built_in">Symbol</span>.iterator]() &#123;</span><br><span class="line">        <span class="keyword">const</span> self = <span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">let</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            next() &#123;</span><br><span class="line">                <span class="keyword">if</span> (index &lt; self.data.length) &#123;</span><br><span class="line">                    <span class="keyword">return</span> &#123;</span><br><span class="line">                        value: self.data[index++],</span><br><span class="line">                        done: <span class="literal">false</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> &#123;</span><br><span class="line">                        value: <span class="literal">undefined</span>,</span><br><span class="line">                        done: <span class="literal">true</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对于类数组对象（存在数值键名和length属性）可以引用数组的Iterator接口来部署</span></span><br><span class="line">NodeList.prototype[<span class="built_in">Symbol</span>.iterator] = <span class="built_in">Array</span>.prototype[<span class="built_in">Symbol</span>.iterator]; </span><br><span class="line"><span class="comment">// 或者 </span></span><br><span class="line">NodeList.prototype[<span class="built_in">Symbol</span>.iterator] = [][<span class="built_in">Symbol</span>.iterator]</span><br><span class="line">[...document.querySelectorAll(<span class="string">'div'</span>)] </span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果Symbol.iterator 方法对应的不是遍历器生成函数（即会返回一 个遍历器对象）会报错</span></span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>因为对象属性的遍历顺序是不确定的  所有没有部署接口  Map部署了接口  对象实际上被当作Map结构使用</p>
</li>
<li>
<p>在下列几个场合中会默认调用<code>Iterator</code>接口</p>
</li>
</ul>
<ol>
<li>解构赋值（对数组和set结构进行解构赋值时）</li>
<li>扩展运算符（任何部署了Iterator接口的数据结构 可以通过扩展运算符转成数组）</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 3. yield* 可遍历的结构 </span></span><br><span class="line"><span class="keyword">let</span> generator = <span class="function"><span class="keyword">function</span>* (<span class="params"></span>) </span>&#123; </span><br><span class="line">    <span class="keyword">yield</span> <span class="number">1</span>; </span><br><span class="line">    <span class="keyword">yield</span>* [<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]; </span><br><span class="line">    <span class="keyword">yield</span> <span class="number">5</span>; </span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> iterator = generator(); </span><br><span class="line">iterator.next() <span class="comment">// &#123; value: 1, done: false &#125; </span></span><br><span class="line">iterator.next() <span class="comment">// &#123; value: 2, done: false &#125; </span></span><br><span class="line">iterator.next() <span class="comment">// &#123; value: 3, done: false &#125; </span></span><br><span class="line">iterator.next() <span class="comment">// &#123; value: 4, done: false &#125; </span></span><br><span class="line">iterator.next() <span class="comment">// &#123; value: 5, done: false &#125; </span></span><br><span class="line">iterator.next() <span class="comment">// &#123; value: undefined, done: true &#125;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 由于数组的遍历会调用遍历器接口  所有任何接收数组作为参数的场合都调用了遍历器接口</span></span><br><span class="line"><span class="comment">// 例如  for...of  Aarray.from()  Map()  Set()  WeakMap() WeakSet() Promise.all() Promise.race()</span></span><br></pre></td></tr></table></figure>
<h5 id="字符串的Iterator接口"><a class="header-anchor" href="#字符串的Iterator接口">¶</a>字符串的Iterator接口</h5>
<ul>
<li>
<p>字符串是一个类似数组的对象  也原生具有Iterator接口</p>
</li>
<li>
<p>可以通过覆盖原生的<code>Symbol.iterator</code>方法  达到修改遍历器行为的目的</p>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">"hi"</span>); </span><br><span class="line">[...str] <span class="comment">// ["h", "i"] </span></span><br><span class="line"></span><br><span class="line">str[<span class="built_in">Symbol</span>.iterator] = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123; </span><br><span class="line">        next: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>._first) &#123;</span><br><span class="line">                <span class="keyword">this</span>._first = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">return</span> &#123; </span><br><span class="line">                    value: <span class="string">"bye"</span>, </span><br><span class="line">                    done: <span class="literal">false</span> </span><br><span class="line">                &#125; </span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; </span><br><span class="line">                <span class="keyword">return</span> &#123; </span><br><span class="line">                    done: <span class="literal">true</span> </span><br><span class="line">                &#125; </span><br><span class="line">            &#125; </span><br><span class="line">        &#125;,</span><br><span class="line">        _first: <span class="literal">true</span> </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line">[...str] <span class="comment">// ["bye"] str // "hi"</span></span><br></pre></td></tr></table></figure>
<h5 id="Iterator接口与Generator函数"><a class="header-anchor" href="#Iterator接口与Generator函数">¶</a>Iterator接口与Generator函数</h5>
<ul>
<li><code>Symbol.iterator</code>方法的最简单实现是使用<code>Generator</code>函数</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myIterable = &#123;&#125;; </span><br><span class="line">myIterable[<span class="built_in">Symbol</span>.iterator] = <span class="function"><span class="keyword">function</span>* (<span class="params"></span>) </span>&#123; </span><br><span class="line">    <span class="keyword">yield</span> <span class="number">1</span>; </span><br><span class="line">    <span class="keyword">yield</span> <span class="number">2</span>; </span><br><span class="line">    <span class="keyword">yield</span> <span class="number">3</span>; </span><br><span class="line">&#125;;</span><br><span class="line">[...myIterable] <span class="comment">// [1, 2, 3] </span></span><br><span class="line"><span class="comment">// 或者采用下面的简洁写法 </span></span><br><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">    * [<span class="built_in">Symbol</span>.iterator]() &#123; </span><br><span class="line">        <span class="keyword">yield</span> <span class="string">'hello'</span>; </span><br><span class="line">        <span class="keyword">yield</span> <span class="string">'world'</span>; </span><br><span class="line">    &#125; </span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> x <span class="keyword">of</span> obj) &#123; </span><br><span class="line">    <span class="built_in">console</span>.log(x); </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// hello // world</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 上面代码中， Symbol.iterator 方法几乎不用部署任何代码，只要用 yield命令给出每一步的返回值即可</span></span><br></pre></td></tr></table></figure>
<h5 id="遍历器对象的return-throw"><a class="header-anchor" href="#遍历器对象的return-throw">¶</a>遍历器对象的return()  throw()</h5>
<ul>
<li>遍历器对象还具有return方法和throw方法  next方法是必须部署的  return方法和throw方法可以选择</li>
</ul>
<h6 id="return"><a class="header-anchor" href="#return">¶</a>return</h6>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果for...of 循环提前退出（通常是因为出错或有break或continue语句）就会调用return方法  如果一个对象在完成遍历前  需要清理或释放资源  就可以部署return方法</span></span><br><span class="line"><span class="comment">// return方法必须返回一个对象</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">readLinesSync</span>(<span class="params">file</span>) </span>&#123; </span><br><span class="line">    <span class="keyword">return</span> &#123; </span><br><span class="line">        next() &#123; </span><br><span class="line">            <span class="keyword">return</span> &#123; </span><br><span class="line">                done: <span class="literal">false</span> </span><br><span class="line">            &#125;; </span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="keyword">return</span>() &#123;</span><br><span class="line">            file.close();</span><br><span class="line">            <span class="keyword">return</span> &#123; </span><br><span class="line">                done: <span class="literal">true</span> </span><br><span class="line">            &#125;; </span><br><span class="line">        &#125;, </span><br><span class="line">    &#125;; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 下列的三种情况都会触发return方法</span></span><br><span class="line"><span class="comment">// 情况一 for </span></span><br><span class="line">(<span class="keyword">let</span> line <span class="keyword">of</span> readLinesSync(fileName)) &#123; </span><br><span class="line">    <span class="built_in">console</span>.log(line); </span><br><span class="line">    <span class="keyword">break</span>;   <span class="comment">// 在执行完break前的语句 就会执行return方法  关闭这个文件</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 情况二 </span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> line <span class="keyword">of</span> readLinesSync(fileName)) &#123; </span><br><span class="line">    <span class="built_in">console</span>.log(line); </span><br><span class="line">    <span class="keyword">continue</span>;  <span class="comment">// 在执行所有代码后  执行return方法  关闭文件</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 情况三 </span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> line <span class="keyword">of</span> readLinesSync(fileName)) &#123; </span><br><span class="line">    <span class="built_in">console</span>.log(line); </span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>();  <span class="comment">// 会执行完return方法后  再抛出错误</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="for…of循环"><a class="header-anchor" href="#for…of循环">¶</a>for…of循环</h3>
<ul>
<li>一个数据结构只要部署了 <code>Symbol.iterator</code> 属性就被视为具有<code>iterator</code>接口，就可以用 for…of 循环遍历它的成员。</li>
<li>也就是说   <code>for...of</code> 循环内部调用的是数据结构的 <code>Symbol.iterator</code> 方法</li>
<li><code>for...of</code> 循环可以使用的范围包括数组、<code>Set</code> 和 <code>Map</code> 结构、某些类似 数组的对象（比如 <code>arguments</code> 对象、<code>DOM NodeList</code> 对象）、后文的<code>Generator</code> 对象，以及字符串</li>
</ul>
<h4 id="数组"><a class="header-anchor" href="#数组">¶</a>数组</h4>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="string">'red'</span>, <span class="string">'green'</span>, <span class="string">'blue'</span>]; </span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> v <span class="keyword">of</span> arr) &#123; </span><br><span class="line">    <span class="built_in">console</span>.log(v); <span class="comment">// red green blue </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 空对象部署了数组得Symbol.iterator属性  产生了一样的结果</span></span><br><span class="line"><span class="keyword">const</span> obj = &#123;&#125;; </span><br><span class="line">obj[<span class="built_in">Symbol</span>.iterator] = arr[<span class="built_in">Symbol</span>.iterator].bind(arr); </span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> v <span class="keyword">of</span> obj) &#123; </span><br><span class="line">    <span class="built_in">console</span>.log(v); <span class="comment">// red green blue </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// for...of循环可以替代数组实例得forEach方法</span></span><br><span class="line"><span class="comment">// for...in循环只能获得对象的键名  不能直接获取键值  for...of循环允许遍历获得键值</span></span><br></pre></td></tr></table></figure>
<h4 id="set和map结构"><a class="header-anchor" href="#set和map结构">¶</a>set和map结构</h4>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> engines = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="string">"Gecko"</span>, <span class="string">"Trident"</span>, <span class="string">"Webkit"</span>, <span class="string">"Webkit"</span>]); </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> e <span class="keyword">of</span> engines) &#123; </span><br><span class="line">    <span class="built_in">console</span>.log(e); </span><br><span class="line">&#125; <span class="comment">// Gecko // Trident // Webkit </span></span><br><span class="line"><span class="keyword">var</span> es6 = <span class="keyword">new</span> <span class="built_in">Map</span>(); </span><br><span class="line">es6.set(<span class="string">"edition"</span>, <span class="number">6</span>); </span><br><span class="line">es6.set(<span class="string">"committee"</span>, <span class="string">"TC39"</span>); </span><br><span class="line">es6.set(<span class="string">"standard"</span>, <span class="string">"ECMA-262"</span>); </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> [name, value] <span class="keyword">of</span> es6) &#123; </span><br><span class="line">    <span class="built_in">console</span>.log(name + <span class="string">": "</span> + value); </span><br><span class="line">&#125; <span class="comment">// edition: 6 // committee: TC39 // standard: ECMA-262</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历的顺序是按照各个成员被添加进数据结构的顺序</span></span><br><span class="line"><span class="comment">// set结构遍历时 返回的是一个值  map结构遍历时  返回的是一个数组  数组的两个成员分别是键名和键值</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>().set(<span class="string">'a'</span>, <span class="number">1</span>).set(<span class="string">'b'</span>, <span class="number">2</span>); </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> pair <span class="keyword">of</span> map) &#123; </span><br><span class="line">    <span class="built_in">console</span>.log(pair); </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ['a', 1] </span></span><br><span class="line"><span class="comment">// ['b', 2] </span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [key, value] <span class="keyword">of</span> map) &#123; </span><br><span class="line">    <span class="built_in">console</span>.log(key + <span class="string">' : '</span> + value); </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// a : 1 </span></span><br><span class="line"><span class="comment">// b : 2</span></span><br></pre></td></tr></table></figure>
<h4 id="计算生成的数据结构"><a class="header-anchor" href="#计算生成的数据结构">¶</a>计算生成的数据结构</h4>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 有些数据结构是在现有数据结构的基础上计算生成的  es6在数组 set map都部署了三个方法调用后都返回遍历器对象</span></span><br><span class="line"><span class="comment">// entries() 返回一个遍历器对象，用来遍历 [键名, 键值] 组成的 数组。对于数组，键名就是索引值；对于 Set，键名与键值相同  Map 结构的 Iterator 接口，默认就是调用 entries 方法。</span></span><br><span class="line"><span class="comment">// keys() 返回一个遍历器对象，用来遍历所有的键名</span></span><br><span class="line"><span class="comment">// values() 返回一个遍历器对象，用来遍历所有的键值</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 三个方法调用后生成遍历器对象  所遍历的都是计算生成的数据结构</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> arr = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>]; </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> pair <span class="keyword">of</span> arr.entries()) &#123; </span><br><span class="line">    <span class="built_in">console</span>.log(pair); </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// [0, 'a'] </span></span><br><span class="line"><span class="comment">// [1, 'b'] </span></span><br><span class="line"><span class="comment">// [2, 'c']</span></span><br></pre></td></tr></table></figure>
<h4 id="类数组对象"><a class="header-anchor" href="#类数组对象">¶</a>类数组对象</h4>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 字符串  for...of循环可以正确识别32位字符</span></span><br><span class="line"><span class="keyword">let</span> str = <span class="string">"hello"</span>; </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> s <span class="keyword">of</span> str) &#123; </span><br><span class="line">    <span class="built_in">console</span>.log(s); <span class="comment">// h e l l o </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// DOM NodeList对象 </span></span><br><span class="line"><span class="keyword">let</span> paras = <span class="built_in">document</span>.querySelectorAll(<span class="string">"p"</span>); </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> p <span class="keyword">of</span> paras) &#123; </span><br><span class="line">    p.classList.add(<span class="string">"test"</span>); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// arguments对象 </span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">printArgs</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> x <span class="keyword">of</span> <span class="built_in">arguments</span>) &#123; </span><br><span class="line">        <span class="built_in">console</span>.log(x); </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line">printArgs(<span class="string">'a'</span>, <span class="string">'b'</span>); <span class="comment">// 'a' // 'b'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以用Array.from方法转为数组的方法解决类数组对象没有接口的问题</span></span><br><span class="line"><span class="keyword">let</span> arrayLike = &#123; <span class="attr">length</span>: <span class="number">2</span>, <span class="number">0</span>: <span class="string">'a'</span>, <span class="number">1</span>: <span class="string">'b'</span> &#125;; </span><br><span class="line"><span class="comment">// 报错 </span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> x <span class="keyword">of</span> arrayLike) &#123; </span><br><span class="line">    <span class="built_in">console</span>.log(x); </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 正确 </span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> x <span class="keyword">of</span> <span class="built_in">Array</span>.from(arrayLike)) &#123; </span><br><span class="line">    <span class="built_in">console</span>.log(x); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="对像"><a class="header-anchor" href="#对像">¶</a>对像</h4>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 对于普通的对象  for...in循环可以遍历键名  for...of循环会报错</span></span><br><span class="line"><span class="comment">// 一种解决办法是使用Object.keys方法将对象的键名生成一个数组  然后遍历这个数组</span></span><br><span class="line"><span class="comment">// 另一个方法是使用Generator函数将对象重新包装</span></span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">entries</span>(<span class="params">obj</span>) </span>&#123; </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">of</span> <span class="built_in">Object</span>.keys(obj)) &#123; </span><br><span class="line">        <span class="keyword">yield</span> [key, obj[key]]; </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [key, value] <span class="keyword">of</span> entries(obj)) &#123; </span><br><span class="line">    <span class="built_in">console</span>.log(key, <span class="string">'-&gt;'</span>, value); </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// a -&gt; 1 </span></span><br><span class="line"><span class="comment">// b -&gt; 2 </span></span><br><span class="line"><span class="comment">// c -&gt; 3</span></span><br></pre></td></tr></table></figure>
<h4 id="与其他遍历方法比较"><a class="header-anchor" href="#与其他遍历方法比较">¶</a>与其他遍历方法比较</h4>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// for循环</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> index = <span class="number">0</span>; index &lt; myArray.length; index++) &#123; 							<span class="built_in">console</span>.log(myArray[index]); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 数组的forEach  问题：无法中途跳出forEach循环  break或return不能奏效</span></span><br><span class="line">myArray.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123; </span><br><span class="line">    <span class="built_in">console</span>.log(value); </span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// for...in遍历键名</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> index <span class="keyword">in</span> myArray) &#123; </span><br><span class="line">    <span class="built_in">console</span>.log(myArray[index]); </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 问题：for...in 循环不仅遍历键名，还会遍历手动添加的其他键， 甚至包括原型链上的键</span></span><br><span class="line"><span class="comment">// 某些情况下  for...in循环会以任意顺序遍历键名</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// for...of</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> value <span class="keyword">of</span> myArray) &#123; </span><br><span class="line">    <span class="built_in">console</span>.log(value); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/07/18/Iterator%E5%92%8Cfor-of%E5%BE%AA%E7%8E%AF/" data-id="ckcrpo1fr0000agvpag4789va" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/es6/" rel="tag">es6</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-代理与反射" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/07/16/%E4%BB%A3%E7%90%86%E4%B8%8E%E5%8F%8D%E5%B0%84/" class="article-date">
  <time datetime="2020-07-16T14:47:37.000Z" itemprop="datePublished">2020-07-16</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/07/16/%E4%BB%A3%E7%90%86%E4%B8%8E%E5%8F%8D%E5%B0%84/">代理与反射</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>[TOC]</p>
<h2 id="Proxy和Reflect"><a class="header-anchor" href="#Proxy和Reflect">¶</a>Proxy和Reflect</h2>
<h3 id="Proxy"><a class="header-anchor" href="#Proxy">¶</a>Proxy</h3>
<ul>
<li>
<p>代理</p>
</li>
<li>
<p><code>Proxy</code>用于修改某些操作的默认行为</p>
</li>
<li>
<pre><code class="language-javascript">// proxy 在目标对象之前提供一层拦截  可以对外界的访问进行过滤和改写
var 变量=new Proxy(对象,{
    get:function(){
        // 操作  当获取该对象的属性是 调用该函数 执行函数中的操作语句 
        return ;// 返回 获取对象的属性值=获取该函数的返回值
    },
    set:function(){
        
    },
    ... // 有很多可以配置的方法
})
 
// proxy实例可以作为其他对象的原型对象
var proxy = new Proxy({}, {
  get: function(target, property) {
    return 35;
  }
});
let obj = Object.create(proxy);
obj.time // 35

// 支持拦截的操作
// 拦截对象属性的获取
get(target,proKey,receiver){}

// 拦截对象属性的设置 返回一个bool
set(target,proKey,value,receiver){}

// 拦截 proKey in proxy 的操作 返回一个bool
has(target,proKey){}

// 拦截 delete proxy[proKey] 的操作  返回一个bool
deleteProperty(target,proKey){}

// 拦截 Object.getOwnPropertyNames(proxy)  Object.getOwnPropertySymbols(proxy)  Object.keys(proxy) 返回一个数组 该方法返回对象自身的所有属性
ownKeys(target){}

// 拦截 Object.getOwnPropertyDescriptor(target,proKey) 返回属性的描述对象
getOwnPropertyDescriptor(target,proKey){}

// 拦截Object.defineProperty(proxy,propKey,propDesc） Object.defineProperties(proxy,propDescs)  返回一个布尔值
defineProperty(target, propKey, propDesc){}

// 拦截Object.preventExtensions(proxy)  返回一个布尔值
preventExtensions(target){}

// 拦截Object.getPrototypeOf(proxy)  返回一个对象
getPrototypeOf(target){}

// 拦截Object.isExtensible(proxy)  返回一个布尔值
isExtensible(target){}

// 拦截Object.setPrototypeOf(proxy, proto)  返回一个布尔值
setPrototypeOf(target, proto){}

// 如果目标对象是函数 还可以进行以下两种拦截
// 拦截 Proxy 实例作为函数调用的操作，比如proxy(...args)、proxy.call(object, ...args)、proxy.apply(...)
apply(target, object, args){}

// 拦截 Proxy 实例作为构造函数调用的操作 比如new proxy(...args)
construct(target, args){}
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#### proxy实例的方法</span><br><span class="line"></span><br><span class="line">##### get</span><br><span class="line"></span><br><span class="line">- &#96;&#96;&#96;javascript</span><br><span class="line">  &#x2F;&#x2F; 用于拦截某个属性的读取操作</span><br><span class="line">  var person &#x3D; &#123;</span><br><span class="line">    name: &quot;张三&quot;</span><br><span class="line">  &#125;;</span><br><span class="line">  var proxy &#x3D; new Proxy(person, &#123;</span><br><span class="line">    get: function(target, property,receiver) &#123;</span><br><span class="line">        &#x2F;&#x2F; 遍历 property为当前属性  target为传入的对象  receiver 为proxy实例本身（即this关键字指向的那个对象）</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">  &#x2F;&#x2F; get方法可以继承  即读取对象继承而来的属性时 会被拦截</span><br><span class="line">  </span><br><span class="line">  &#x2F;&#x2F; 如果一个属性不可配置（configurable）和不可写（writable）则该属性不能被代理 通过proxy对象访问该属性会报错</span><br></pre></td></tr></table></figure>

</code></pre>
</li>
</ul>
<h5 id="set"><a class="header-anchor" href="#set">¶</a>set</h5>
<ul>
<li>
<pre><code class="language-javascript">// 用来拦截某个属性的赋值操作
var person = new Proxy({}, {
  set: function(target, property,value,receiver) {
      // 遍历 value为当前属性的值 property为当前属性  target为传入的对象  receiver为proxy实例
  }
});
// 如果目标对象的某个属性不可写也不可配置 那么set不能改变这个属性的值  只能返回同样的值  否则报错
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">##### apply</span><br><span class="line"></span><br><span class="line">- &#96;&#96;&#96;javascript</span><br><span class="line">  &#x2F;&#x2F; 当传入的是函数时才可以配置该方法 拦截函数的调用、call、apply操作  当调用函数时 会调用apply方法  直接调用Reflect.apply也会被拦截</span><br><span class="line">  var target &#x3D; function () &#123; </span><br><span class="line">      return &#39;I am the target&#39; </span><br><span class="line">  &#125;</span><br><span class="line">  var p &#x3D; new Proxy(target, &#123;</span><br><span class="line">      apply: function (target, object, args) &#123;</span><br><span class="line">          &#x2F;&#x2F; args为原函数的参数数组 target为目标对象  object为目标对象的this（谁调用就是谁）</span><br><span class="line">      	return &#39;I am the proxy&#39;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  p() &#x2F;&#x2F; &#39;I am the proxy&#39;</span><br></pre></td></tr></table></figure>

</code></pre>
</li>
</ul>
<h5 id="has"><a class="header-anchor" href="#has">¶</a>has</h5>
<ul>
<li>
<pre><code class="language-javascript">// 用来拦截hasProperty操作（即判断对象是否含有某个属性时生效） 自身属性与继承属性都会生效
// in操作符 不会拦截for in循环
var target = { _prop: 'foo', prop: 'foo' };
var proxy = new Proxy(target,{
    has (target, key) {
    // key 属性 target 对象
    }
});
// 如果原对象不可配置或禁止扩展（Object.preventExtensions(对象)） has拦截会报错
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">##### constructor</span><br><span class="line"></span><br><span class="line">- &#96;&#96;&#96;javascript</span><br><span class="line">  &#x2F;&#x2F; 当传入的是函数时才可以配置该方法  拦截new命令</span><br><span class="line">  var p &#x3D; new Proxy(function() &#123;&#125;, &#123;</span><br><span class="line">    construct: function(target, args) &#123;</span><br><span class="line">    		&#x2F;&#x2F; target 目标对象  args 函数的参数数组 </span><br><span class="line">          &#x2F;&#x2F; 返回的必须是一个对象  否则会报错 **</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure>

</code></pre>
</li>
</ul>
<h5 id="deleteProperty"><a class="header-anchor" href="#deleteProperty">¶</a>deleteProperty</h5>
<ul>
<li>
<pre><code class="language-javascript">// 拦截delete操作  如果当前方法抛出错误或返回false 当前属性就无法被delete删除
var target = { _prop: 'foo' };
var proxy = new Proxy(target, {
    deleteProperty (target, key) {
		// target 对象 key 属性    
    }
})
// 如果目标对象的不可配置的属性  不能被deleteProperty方法删除  否则报错
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">##### defineProperty</span><br><span class="line"></span><br><span class="line">- &#96;&#96;&#96;javascript </span><br><span class="line">  &#x2F;&#x2F; 拦截Object.defineProperty操作</span><br><span class="line">  var target &#x3D; &#123;&#125;;</span><br><span class="line">  var proxy &#x3D; new Proxy(target, &#123;</span><br><span class="line">      defineProperty (target, key, descriptor) &#123;</span><br><span class="line">      	return false;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">  proxy.foo &#x3D; &#39;bar&#39; &#x2F;&#x2F; 返回false会导致添加新属性报错</span><br><span class="line">  &#x2F;&#x2F; 如果目标对象不可扩展 则defineProperty不能增加目标对象上不存在的属性  否则报错</span><br><span class="line">  &#x2F;&#x2F; 如果目标对象的某个属性不可写或不可配置  defineProperty 方法不得改变这两个设置</span><br></pre></td></tr></table></figure>

</code></pre>
</li>
</ul>
<h5 id="getOwnPropertyDescriptor"><a class="header-anchor" href="#getOwnPropertyDescriptor">¶</a>getOwnPropertyDescriptor()</h5>
<ul>
<li>
<pre><code class="language-javascript">// 拦截Object.getOwnPropertyDescriptor()  返回一个属性描述对象或undefined
var handler = { };
var target = { _foo: 'bar', baz: 'tar' }; 
var proxy = new Proxy(target, {
     getOwnPropertyDescriptor (target, key){
         // target 传入的对像  key 属性
         return Object.getOwnPropertyDescriptor(target, key);
     }
});
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">##### getPrototypeOf</span><br><span class="line"></span><br><span class="line">- &#96;&#96;&#96;javascript</span><br><span class="line">  &#x2F;&#x2F; 拦截获取对象的原型 </span><br><span class="line">  &#x2F;&#x2F; 即下列方法 Object.prototype.__proto__  instanceof Object.getPrototypeOf() Reflect.getPrototypeOf() Object.prototype.isPrototypeOf() </span><br><span class="line">  &#x2F;&#x2F; 返回值必须是对象或nul</span><br><span class="line">  &#x2F;&#x2F; 如果目标对象不可扩展 必须返回目标对象的原型</span><br><span class="line">  var proto &#x3D; &#123;&#125;; var p &#x3D; new Proxy(&#123;&#125;, &#123; </span><br><span class="line">      getPrototypeOf(target) &#123; </span><br><span class="line">          &#x2F;&#x2F; target 目标对象 </span><br><span class="line">      &#125; </span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure>

</code></pre>
</li>
</ul>
<h5 id="isExtensible"><a class="header-anchor" href="#isExtensible">¶</a>isExtensible</h5>
<ul>
<li>
<pre><code class="language-javascript">// 拦截 Object.isExtensible  只能返回bool 否则自动转为bool
// 它的返回值必须与目标对象的 isExtensible 属性保持一致  否则就会抛出错误
var p = new Proxy({}, { 
    isExtensible: function(target) { 
        // target 目标对象
    } 
})
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">##### ownKeys</span><br><span class="line"></span><br><span class="line">- &#96;&#96;&#96;javascript</span><br><span class="line">  &#x2F;&#x2F; 拦截对象自身属性的读取操作</span><br><span class="line">  &#x2F;&#x2F; 即以下操作 Object.getOwnPropertyNames() Object.getOwnPropertySymbols() Object.keys()</span><br><span class="line">  &#x2F;&#x2F; 有三类属性会被 ownKeys 方法自动 过滤，不会返回。 目标对象上不存在的属性 属性名为 Symbol 值 不可遍历（ enumerable ）的属性</span><br><span class="line">  &#x2F;&#x2F; 返回一个数组  数组成员只能是字符串或symbol值  否则报错</span><br><span class="line">  &#x2F;&#x2F; 如果目标对象是不可扩展的  返回的数组中只能包含原对象的所有属性（不能多不能少）</span><br><span class="line">  let target &#x3D; &#123;&#125;</span><br><span class="line">  let proxy &#x3D; new Proxy(target, &#123;</span><br><span class="line">      ownKeys(target) &#123;</span><br><span class="line">          &#x2F;&#x2F; target 目标对象</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure>

</code></pre>
</li>
</ul>
<h5 id="preventExtensions"><a class="header-anchor" href="#preventExtensions">¶</a>preventExtensions</h5>
<ul>
<li>
<pre><code class="language-javascript">// 拦截 Object.preventExtensions()  返回一个bool 否则自动转为bool
// 当目标对象不可扩展（ Object.isExtensible(proxy) 为 false）时  才能false 否则报错  所有通常需要在该方法中调用Object.preventExtensions
var p = new Proxy({}, { 
    preventExtensions: function(target) { 
        // target 目标对象
    } 
})
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">##### setPrototypeOf</span><br><span class="line"></span><br><span class="line">- &#96;&#96;&#96;javascript</span><br><span class="line">  &#x2F;&#x2F; 拦截 Object.setPrototypeOf 只能返回bool 否则自动转为bool</span><br><span class="line">  &#x2F;&#x2F; 目标对象不可扩展 该方法不能改变目标对象的原型</span><br><span class="line">  var target &#x3D; function () &#123;&#125;</span><br><span class="line">  var proxy &#x3D; new Proxy(target, &#123;</span><br><span class="line">      setPrototypeOf (target, proto) &#123;</span><br><span class="line">      	&#x2F;&#x2F; target 目标对象  proto 原型对象   </span><br><span class="line">      &#125;</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure>

</code></pre>
</li>
</ul>
<h5 id="Proxy-revocable"><a class="header-anchor" href="#Proxy-revocable">¶</a>Proxy.revocable</h5>
<ul>
<li>
<pre><code class="language-javascript">// 返回一个对象，该对象的 proxy 属性 是 Proxy 实例， revoke 属性是一个函数，可以取消 Proxy 实例。上 面代码中，当执行 revoke 函数之后，再访问 Proxy 实例，就会抛出 一个错误
let target = {}; 
let handler = {}; 
let {proxy, revoke} = Proxy.revocable(target, handler); 
proxy.foo = 123; 
proxy.foo // 123 revoke(); proxy.foo // TypeError: Revoked
//Proxy.revocable 的一个使用场景是，目标对象不允许直接访问，必 须通过代理访问，一旦访问结束，就收回代理权，不允许再次访问
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">##### this问题</span><br><span class="line"></span><br><span class="line">- &#96;&#96;&#96;javascript</span><br><span class="line">  &#x2F;&#x2F; 目标对象内部的this会指向proxy代理</span><br><span class="line">  const target &#x3D; &#123; m: function () &#123; console.log(this &#x3D;&#x3D;&#x3D; proxy); &#125; &#125;;</span><br><span class="line">  const handler &#x3D; &#123;&#125;; </span><br><span class="line">  const proxy &#x3D; new Proxy(target, handler); </span><br><span class="line">  target.m() &#x2F;&#x2F; false </span><br><span class="line">  proxy.m() &#x2F;&#x2F; true</span><br><span class="line">  </span><br><span class="line">  &#x2F;&#x2F; 解决</span><br><span class="line">  const target &#x3D; new Date(&#39;2015-01-01&#39;); </span><br><span class="line">  const handler &#x3D; &#123; </span><br><span class="line">      get(target, prop) &#123; </span><br><span class="line">          if (prop &#x3D;&#x3D;&#x3D; &#39;getDate&#39;) &#123; </span><br><span class="line">              return target.getDate.bind(target); </span><br><span class="line">          &#125;</span><br><span class="line">          return Reflect.get(target, prop); </span><br><span class="line">      &#125; </span><br><span class="line">  &#125;;</span><br><span class="line">  const proxy &#x3D; new Proxy(target, handler); </span><br><span class="line">  proxy.getDate() &#x2F;&#x2F; 1</span><br></pre></td></tr></table></figure>



</code></pre>
</li>
</ul>
<h3 id="reflect"><a class="header-anchor" href="#reflect">¶</a>reflect</h3>
<ul>
<li>目的（1）：将<code>Object</code>对象的一些明显属于语言内部的方法 放到<code>reflect</code>对象上  现阶段某些方法同时在两个对象上部署   以后的新方法只在<code>reflect</code>上部署</li>
<li>目的（2）：修改某些<code>Object</code>方法的返回结果</li>
<li>目的（3）：让<code>Object</code>操作都变成函数行为</li>
<li>目的（4）：<code>reflect</code>对象的方法和<code>proxy</code>对象的方法一一对应  让<code>proxy</code>可以方便地调用对于<code>reflect</code>方法</li>
</ul>
<h4 id="静态方法"><a class="header-anchor" href="#静态方法">¶</a>静态方法</h4>
<h5 id="Reflect-apply-target-thisArg-args"><a class="header-anchor" href="#Reflect-apply-target-thisArg-args">¶</a>Reflect.apply(target, thisArg, args)</h5>
<ul>
<li>
<pre><code class="language-javascript">// 等同于function.prototype.apply.call(func,thisArg,args)
// 绑定一个函数的this对象 可以使用 fn.apply(this对象,参数数组) 如果函数定义了自己的apply方法  就只能写成上面的形式

// 不知道上面在说啥  反正以后为函数绑定this对象直接像下面一样用就行了
Reflect.apply(函数,this对象,参数数组)
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">##### Reflect.construct(target, args) </span><br><span class="line"></span><br><span class="line">- &#96;&#96;&#96;javascript</span><br><span class="line">  &#x2F;&#x2F; Reflect.construct(target,args) 相当于 new target(args)</span><br><span class="line">  &#x2F;&#x2F; 提供了一种不使用new 来调用构造函数的方法</span><br><span class="line">  function Greeting(name) &#123;</span><br><span class="line">      this.name &#x3D; name; </span><br><span class="line">  &#125;</span><br><span class="line">  &#x2F;&#x2F; new 的写法 </span><br><span class="line">  const instance &#x3D; new Greeting(&#39;张三&#39;); </span><br><span class="line">  &#x2F;&#x2F; Reflect.construct 的写法 </span><br><span class="line">  const instance &#x3D; Reflect.construct(Greeting, [&#39;张三&#39;]);</span><br></pre></td></tr></table></figure>

</code></pre>
</li>
</ul>
<h5 id="Reflect-get-target-name-receiver"><a class="header-anchor" href="#Reflect-get-target-name-receiver">¶</a>Reflect.get(target, name, receiver)</h5>
<ul>
<li>
<pre><code class="language-javascript">Reflect.get(对象,属性,对象)
// 查找并返回第一个对象的指定属性  如果没有则返回undefined 如果参数不是对象 报错
// 如果该对象或该属性部署了读取函数  让读取函数中的this=第三个参数 再调用读取函数
var myObject = { 
    foo: 1, 
    bar: 2, 
    get baz() { 
        return this.foo + this.bar; 
    }
};
var myReceiverObject = { 
    foo: 4, 
    bar: 4, 
}
Reflect.get(myObject, 'baz', myReceiverObject) // 8
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">##### Reflect.set(target, name, value, receiver) </span><br><span class="line"></span><br><span class="line">- &#96;&#96;&#96;javascript</span><br><span class="line">  Reflect.set(对象,属性,值,对象)</span><br><span class="line">  &#x2F;&#x2F; 设置第一个对象指定的属性的值  如果第一个参数不是对象 报错</span><br><span class="line">  &#x2F;&#x2F; 如果该对象或该属性部署了赋值函数  让读取函数中的this&#x3D;第四个参数 再调用赋值函数</span><br><span class="line">  var myObject &#x3D; &#123; </span><br><span class="line">      foo: 4, </span><br><span class="line">      set bar(value) &#123; </span><br><span class="line">          return this.foo &#x3D; value; </span><br><span class="line">      &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  var myReceiverObject &#x3D; &#123; foo: 0 &#125;;</span><br><span class="line">  Reflect.set(myObject, &#39;bar&#39;, 1, myReceiverObject); </span><br><span class="line">  myObject.foo &#x2F;&#x2F; 4 </span><br><span class="line">  myReceiverObject.foo &#x2F;&#x2F; 1</span><br><span class="line">  </span><br><span class="line">  &#x2F;&#x2F; 如果proxy和reflect联合使用  前者拦截赋值操作 后者完成赋值的默认行为 而且传入了 receiver  那么 Reflect.set 会触发 Proxy.defineProperty 拦截</span><br><span class="line">  let p &#x3D; &#123; a: &#39;a&#39; &#125;;</span><br><span class="line">  let handler &#x3D; &#123; </span><br><span class="line">      set(target, key, value, receiver) &#123; </span><br><span class="line">          console.log(&#39;set&#39;); </span><br><span class="line">          Reflect.set(target, key, value, receiver) </span><br><span class="line">      &#125;,</span><br><span class="line">      defineProperty(target, key, attribute) &#123;</span><br><span class="line">          console.log(&#39;defineProperty&#39;); </span><br><span class="line">          Reflect.defineProperty(target, key, attribute); </span><br><span class="line">      &#125; </span><br><span class="line">  &#125;;</span><br><span class="line">  let obj &#x3D; new Proxy(p, handler); </span><br><span class="line">  obj.a &#x3D; &#39;A&#39;; </span><br><span class="line">  &#x2F;&#x2F; set </span><br><span class="line">  &#x2F;&#x2F; defineProperty</span><br></pre></td></tr></table></figure>

</code></pre>
</li>
</ul>
<h5 id="Reflect-defineProperty-target-name-desc"><a class="header-anchor" href="#Reflect-defineProperty-target-name-desc">¶</a>Reflect.defineProperty(target, name, desc)</h5>
<ul>
<li>
<pre><code class="language-javascript">// 基本等同于Object.defineProperty 用于定义对象属性
Reflect.defineProperty(对象,'属性',{
    // 配置 即数据属性 访问器属性的特性
})
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">##### Reflect.deleteProperty(target, name) </span><br><span class="line"></span><br><span class="line">- &#96;&#96;&#96;javascript</span><br><span class="line">  &#x2F;&#x2F; 相当于delete  返回一个bool 如果成功或被删除的属性不存在 返回true 删除失败 返回false</span><br><span class="line">  const myObj &#x3D; &#123; foo: &#39;bar&#39; &#125;; </span><br><span class="line">  &#x2F;&#x2F; 旧写法 </span><br><span class="line">  delete myObj.foo; </span><br><span class="line">  &#x2F;&#x2F; 新写法 </span><br><span class="line">  Reflect.deleteProperty(myObj, &#39;foo&#39;);</span><br></pre></td></tr></table></figure>

</code></pre>
</li>
</ul>
<h5 id="Reflect-has-target-name"><a class="header-anchor" href="#Reflect-has-target-name">¶</a>Reflect.has(target, name)</h5>
<ul>
<li>
<pre><code class="language-javascript">// 相当于in运算符  如果第一个参数不是对象 报错
var myObject = { foo: 1, };
// 旧写法 
'foo' in myObject // true 
// 新写法 
Reflect.has(myObject, 'foo') // true
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">##### Reflect.ownKeys(target) </span><br><span class="line"></span><br><span class="line">- &#96;&#96;&#96;javascript</span><br><span class="line">  &#x2F;&#x2F; 返回对象的所有属性（包括symbol属性）</span><br><span class="line">  var myObject &#x3D; &#123; </span><br><span class="line">      foo: 1, </span><br><span class="line">      bar: 2, </span><br><span class="line">      [Symbol.for(&#39;baz&#39;)]: 3, </span><br><span class="line">      [Symbol.for(&#39;bing&#39;)]: 4, </span><br><span class="line">  &#125;;</span><br><span class="line">  &#x2F;&#x2F; 旧写法 </span><br><span class="line">  Object.getOwnPropertyNames(myObject) &#x2F;&#x2F; [&#39;foo&#39;, &#39;bar&#39;] </span><br><span class="line">  Object.getOwnPropertySymbols(myObject) &#x2F;&#x2F;[Symbol(baz), Symbol(bing)] </span><br><span class="line">  </span><br><span class="line">  &#x2F;&#x2F; 新写法 </span><br><span class="line">  Reflect.ownKeys(myObject) &#x2F;&#x2F; [&#39;foo&#39;, &#39;bar&#39;, Symbol(baz), Symbol(bing)]</span><br></pre></td></tr></table></figure>

</code></pre>
</li>
</ul>
<h5 id="Reflect-isExtensible-target"><a class="header-anchor" href="#Reflect-isExtensible-target">¶</a>Reflect.isExtensible(target)</h5>
<ul>
<li>
<pre><code class="language-javascript">// 返回一个bool 表示对象是否可扩展
const myObject = {}; 
// 旧写法 
Object.isExtensible(myObject) // true 
// 新写法 
Reflect.isExtensible(myObject) // true
// 如果不是对象 旧写法返回false 新写法报错
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">##### Reflect.preventExtensions(target) </span><br><span class="line"></span><br><span class="line">- &#96;&#96;&#96;javascript</span><br><span class="line">  &#x2F;&#x2F; 用于将一个对象变为不可扩展  返回一个bool 表示是否操作成功</span><br><span class="line">  var myObject &#x3D; &#123;&#125;; </span><br><span class="line">  &#x2F;&#x2F; 旧写法 </span><br><span class="line">  Object.preventExtensions(myObject) &#x2F;&#x2F; Object &#123;&#125; </span><br><span class="line">  &#x2F;&#x2F; 新写法 </span><br><span class="line">  Reflect.preventExtensions(myObject) &#x2F;&#x2F; true</span><br><span class="line">  &#x2F;&#x2F; 如果不是参数不是对象 es5环境中旧写法报错  es6中旧写法返回传入参数  新写法报错</span><br></pre></td></tr></table></figure>

</code></pre>
</li>
</ul>
<h5 id="Reflect-getOwnPropertyDescriptor-target-name"><a class="header-anchor" href="#Reflect-getOwnPropertyDescriptor-target-name">¶</a>Reflect.getOwnPropertyDescriptor(target, name)</h5>
<ul>
<li>
<pre><code class="language-javascript">// 等同于Object.getOwnPropertyDescriptor  得到指定属性的描述对象
var myObject = {}; 
Object.defineProperty(myObject, 'hidden', {
    value: true, 
    enumerable: false, 
}); 
// 旧写法 
var theDescriptor = Object.getOwnPropertyDescriptor(对象, '属性'); 
// 新写法 
var theDescriptor = Reflect.getOwnPropertyDescriptor(对象, '属性');
// 返回第三个参数

// 如果第一个参数不是对象旧写法返回undefined  新写法报错
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">##### Reflect.getPrototypeOf(target) </span><br><span class="line"></span><br><span class="line">- &#96;&#96;&#96;javascript</span><br><span class="line">  &#x2F;&#x2F; 读取对象的__proto__属性（ 即Object.getPrototypeOf(obj) ）</span><br><span class="line">  const myObj &#x3D; new FancyThing(); </span><br><span class="line">  &#x2F;&#x2F; 旧写法 </span><br><span class="line">  Object.getPrototypeOf(myObj) &#x3D;&#x3D;&#x3D; FancyThing.prototype; </span><br><span class="line">  &#x2F;&#x2F; 新写法 </span><br><span class="line">  Reflect.getPrototypeOf(myObj) &#x3D;&#x3D;&#x3D; FancyThing.prototype;</span><br><span class="line">  &#x2F;&#x2F; 两个方法的区别：如果参数不是对象 Object.getPrototypeOf(obj)会将这个参数转为对象  而Reflect.getPrototypeOf(target) 会报错</span><br></pre></td></tr></table></figure>

</code></pre>
</li>
</ul>
<h5 id="Reflect-setPrototypeOf-target-prototype"><a class="header-anchor" href="#Reflect-setPrototypeOf-target-prototype">¶</a>Reflect.setPrototypeOf(target, prototype)</h5>
<ul>
<li>
<pre><code class="language-javascript">// 用于设置对象的__proto__属性  返回第一个参数对象
const myObj = new FancyThing(); 
// 旧写法 
Object.setPrototypeOf(对象, 原型); 
// 新写法 
Reflect.setPrototypeOf(对象, 原型);
// 如果第一个参数不是对象， Object.setPrototypeOf 会返回第一个参 数本身，而 Reflect.setPrototypeOf 会报错
// 如果第一个参数 是 undefined 或 null ， Object.setPrototypeOf 和 Reflect.set PrototypeOf 都会报错
</code></pre>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/07/16/%E4%BB%A3%E7%90%86%E4%B8%8E%E5%8F%8D%E5%B0%84/" data-id="ckcowsf190000akvp0xpwhwq9" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/es6/" rel="tag">es6</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-js的一些基础知识（查缺补漏）" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/07/15/js%E7%9A%84%E4%B8%80%E4%BA%9B%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%EF%BC%88%E6%9F%A5%E7%BC%BA%E8%A1%A5%E6%BC%8F%EF%BC%89/" class="article-date">
  <time datetime="2020-07-15T01:47:06.000Z" itemprop="datePublished">2020-07-15</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/07/15/js%E7%9A%84%E4%B8%80%E4%BA%9B%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%EF%BC%88%E6%9F%A5%E7%BC%BA%E8%A1%A5%E6%BC%8F%EF%BC%89/">js的一些基础知识（查缺补漏）</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>[TOC]</p>
<h2 id="异步加载"><a class="header-anchor" href="#异步加载">¶</a>异步加载</h2>
<ul>
<li>
<pre><code class="language-html">
// defer  异步加载，但要等到dom文档全部解析完才会被执行
&lt;script type=&quot;text/javascript&quot; defer=&quot;defer&quot;&gt; 
//代码区
&lt;/script&gt; 

// async  步加载，加载完就执行，async只能加载外部脚本，不能把js写在script 标签里。
&lt;script type=&quot;text/javascript&quot; src=&quot;demo.js&quot; async=&quot;async&quot;&gt;&lt;/script&gt; 

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">  </span><br><span class="line">- js控制</span><br><span class="line"></span><br><span class="line">- &#96;&#96;&#96;JavaScript</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 创建script 插入dom中  加载完毕后callback</span><br><span class="line">  function asyncLoaded(url, callBack) &#123;</span><br><span class="line">          var script &#x3D; document.createElement(&#39;script&#39;);</span><br><span class="line">          script.type &#x3D; &#39;text&#x2F;javascript&#39;;</span><br><span class="line">          if (script.readystate) &#123;&#x2F;&#x2F;兼容IE</span><br><span class="line">              script.onreadystatechange &#x3D; function () &#123;&#x2F;&#x2F;状态改变触发事件</span><br><span class="line">                  if (script.readyState &#x3D;&#x3D; &#39;loaded&#39; || script.readyState &#x3D;&#x3D; &#39;complete&#39;) &#123;</span><br><span class="line">                      callBack();</span><br><span class="line">                      script.onreadystatechange &#x3D; null;</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125; else &#123;</span><br><span class="line">              script.onload &#x3D; function (e) &#123;</span><br><span class="line">                  callBack();</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          script.src &#x3D; url;</span><br><span class="line">          document.body.appendChild(script);</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>



</code></pre>
</li>
</ul>
<h2 id="时间线"><a class="header-anchor" href="#时间线">¶</a>时间线</h2>
<ol>
<li>创建Documen对象开始解析web页面。解析HTML元素和他们的文本内容后添加Element对象和Text节点到文档中。这个阶段document.readyState = ‘loading’ 。</li>
<li>遇到link外部css,创建线程加载，井继续解析文档。</li>
<li>遇到script外部js，并且没有设置async，defer, 浏览器加载，并阻塞，等待js加载完成并执行该脚本，然后继续解析文档。</li>
<li>遇到script外部js.并且设置有async， defer, 浏览器创建线程加载，并继续解析文档。对于async属性的脚本，脚本加载完成后立即执行。(异步禁止使用document.write()，因为它会清除文档流）</li>
<li>遇到img等，先正常解析dom结构，然后浏览器异步加载src,并继续解析文档。</li>
<li>当文档解析完成，document.readyState = ‘Interactive’。</li>
<li>文档解析完成后，所有设置有defer的脚本会按照顺序执行。(注意 async的不同，但同样禁止使用document.wite()) ;</li>
<li>document对象触发DOMContentLoaded事件，这也标志着程序执行从同步脚本执行阶段，转化为事件驱动阶段。</li>
<li>当所有async的脚本加载完成井执行后。img等加载完成后，document.readyState = ‘complete’, window对象触发load事件。</li>
<li>以异步响应方式处理用户输入，网络事件等。</li>
</ol>
<h2 id="命名空间"><a class="header-anchor" href="#命名空间">¶</a>命名空间</h2>
<ul>
<li>
<pre><code class="language-javascript">
// 在多人合作中 每个人写的变量名 函数名都各不相同  有可能会造成相互冲突或者污染的问题

var 对象=function(){
    // 定义变量 方法
    return {
        // 需要暴露的方法和变量
    }
}

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 在外界可以通过访问该对象的属性与方法来进行工作</span><br><span class="line">## arguments</span><br><span class="line"></span><br><span class="line">- 函数中的一个特殊属性</span><br><span class="line"></span><br><span class="line">- &#96;&#96;&#96;javascript</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 函数可以通过arguments数组来接收参数（是一个对象 不是Array的实例）</span><br><span class="line">  &#x2F;&#x2F; arguments[0] 表示第一个参数 arguments[1] 表示第二个参数  以此类推</span><br><span class="line">  &#x2F;&#x2F; arguments.length 代表传递进来的参数的数量（不是定义函数时规定的参数的数量）</span><br><span class="line">  &#x2F;&#x2F; arguments[i]的值会与第i+1个参数的值同步（修改其中一方 另外一方也会改变）</span><br><span class="line">  &#x2F;&#x2F; 当修改arguments[i]的值 但第i+1个参数没有被传递进来  第i+1个参数值不变（仍为undefined）</span><br><span class="line">  </span><br><span class="line">  &#x2F;&#x2F; arguments.callee 执行该arguments对象的函数 使用下列第二种写法</span><br><span class="line">  function a(num)&#123;</span><br><span class="line">      if(num&lt;&#x3D;1)&#123;</span><br><span class="line">          return 1</span><br><span class="line">      &#125;else&#123;</span><br><span class="line">          return num*a(num-1)</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  function a(num)&#123;</span><br><span class="line">      if(num&lt;&#x3D;1)&#123;</span><br><span class="line">          return 1</span><br><span class="line">      &#125;else&#123;</span><br><span class="line">          return num*arguments.callee(num-1) &#x2F;&#x2F; arguments.callee &#x3D;&#x3D; a</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>



</code></pre>
</li>
</ul>
<h2 id="克隆"><a class="header-anchor" href="#克隆">¶</a>克隆</h2>
<h3 id="浅克隆"><a class="header-anchor" href="#浅克隆">¶</a>浅克隆</h3>
<ul>
<li>
<p>= 扩展运算符  Object.create</p>
</li>
<li>
<pre><code class="language-javascript">
// 使用 = 符号
const obj = {one: 1, two: 2};
const obj2 = obj;
// 使用扩展运输符  注意被clone的对象模式（解构赋值可能失败）
const food = { beef: '牛排', bacon: '咸肉' }
{ ...food }
// 使用 Object.assign(对象1,对象2,...)  返回合并后的对象1 将后面的对象的所有可枚举属性复制到对象1中  如果有同名对象 以后面的对象为准 如果不是对象 会转成对象返回 
const food = { beef: '牛排', bacon: '咸肉' }
const cloneFood = Object.assign({}, food);

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">  </span><br><span class="line">- 只能复制属性与方法  没有改变指向问题（改变其中一个  另一个也会改变）</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 深克隆</span><br><span class="line">- json方法或库</span><br><span class="line"></span><br><span class="line">- &#96;&#96;&#96;javascript</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 使用 json  JSON.stringify&#x2F;parse 仅对数字、字符串和不含symbol属性的对象有效</span><br><span class="line">  const food &#x3D; &#123; beef: &#39;牛排&#39;, bacon: &#39;咸肉&#39; &#125;</span><br><span class="line">  const cloneFood &#x3D; JSON.parse(JSON.stringify(food))</span><br><span class="line">  &#x2F;&#x2F; 使用 jquery的 $.extend()</span><br><span class="line">  &#x2F;&#x2F; 使用underscore.js 的 _.clone()</span><br><span class="line">  &#x2F;&#x2F; deepClone 对所有类型有效  函数和symbol会通过引用复制</span><br><span class="line">  const lodashClonedeep &#x3D; require(&quot;lodash.clonedeep&quot;);</span><br></pre></td></tr></table></figure>

</code></pre>
</li>
<li>
<p>属性和方法相同  但没有关联</p>
</li>
</ul>
<h2 id="this指向"><a class="header-anchor" href="#this指向">¶</a>this指向</h2>
<h3 id="默认绑定"><a class="header-anchor" href="#默认绑定">¶</a>默认绑定</h3>
<ul>
<li>
<p>回调函数或直接调用</p>
</li>
<li>
<pre><code class="language-javascript">
// 一般发生在回调函数中或函数直接调用
function test() {
	console.log(this); //window 或 严格模式下是undefined
}

setTimeout(function () {
	console.log(this); 
	// 都是window
});

arr.forEach(function(){
	console.log(this);  //window 或严格模式下是undefined
});

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 注意严格模式与正常模式的不同</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 隐式绑定</span><br><span class="line"></span><br><span class="line">- 作用域</span><br><span class="line"></span><br><span class="line">- &#96;&#96;&#96;JavaScript</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 谁调用就指向谁</span><br><span class="line">  &#x2F;&#x2F; 例1</span><br><span class="line">      const obj &#x3D; &#123;</span><br><span class="line">          name:&#39;joy&#39;,</span><br><span class="line">          getName()&#123;</span><br><span class="line">              console.log(this);  </span><br><span class="line">              console.log(this.name);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;;</span><br><span class="line">      obj.getName(); &#x2F;&#x2F; obj  joy</span><br><span class="line">  &#x2F;&#x2F; 例2</span><br><span class="line">      const obj1 &#x3D; &#123;</span><br><span class="line">          name:&#39;joy&#39;,</span><br><span class="line">          getName()&#123;</span><br><span class="line">              console.log(this); &#x2F;&#x2F;obj</span><br><span class="line">              console.log(this.name); &#x2F;&#x2F;joy</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;;</span><br><span class="line">      const obj2 &#x3D; &#123;</span><br><span class="line">          name:&#39;sam&#39;,</span><br><span class="line">          friend:obj1</span><br><span class="line">      &#125;;</span><br><span class="line">      const obj3 &#x3D; &#123;</span><br><span class="line">          name: &#39;jam&#39;,</span><br><span class="line">          friend:obj2</span><br><span class="line">      &#125;;</span><br><span class="line">      obj3.friend.friend.getName()  &#x2F;&#x2F; obj joy 本质上还是obj1调用的</span><br><span class="line">  &#x2F;&#x2F; 例3</span><br><span class="line">      const obj1 &#x3D; &#123;</span><br><span class="line">          name:&#39;joy&#39;,</span><br><span class="line">          getName()&#123;</span><br><span class="line">              console.log(this); </span><br><span class="line">              console.log(this.name); </span><br><span class="line">          &#125;</span><br><span class="line">      &#125;;</span><br><span class="line">  </span><br><span class="line">      const obj2 &#x3D; &#123;</span><br><span class="line">          name:&#39;sam&#39;,</span><br><span class="line">          getName:obj1.getName</span><br><span class="line">      &#125;;</span><br><span class="line">  </span><br><span class="line">      obj2.getName()  &#x2F;&#x2F; obj2 sam</span><br></pre></td></tr></table></figure>

</code></pre>
</li>
<li>
<p>注意分析是谁调用的</p>
</li>
</ul>
<h3 id="显示绑定（call-apply-bind）"><a class="header-anchor" href="#显示绑定（call-apply-bind）">¶</a>显示绑定（call,apply,bind）</h3>
<ul>
<li>
<p>指定this</p>
</li>
<li>
<pre><code class="language-javascript">
    const obj1 = {
        name:'joy',
        getName(){
            console.log(this); //obj
            console.log(this.name); //joy
        }
    };

    const obj2 = {
        name:'sam'
    };

    obj1.getName.call(obj2); //obj2 sam
    obj1.getName.apply(obj2); //obj2 sam
    
    const fn = obj1.getName.bind(obj2);
    fn();//obj2 sam

// call和apply之间就是传参的方式不同
    fn.apply(this,[1,2]); // 不管多少个,都用数组包裹传参
    fn.call(this,1,2); // 一个个参数列出来传

// call和apply都是即时调用,绑定既是调用,而bind不是,bind会返回绑定后的函数,自行需要的时候再调用

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 在继承时会用到</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### new绑定</span><br><span class="line"></span><br><span class="line">- new</span><br><span class="line"></span><br><span class="line">- &#96;&#96;&#96;javascript</span><br><span class="line"></span><br><span class="line">      function Vehicle() &#123;</span><br><span class="line">          console.log(this);</span><br><span class="line">      &#125;</span><br><span class="line">      Vehicle(); &#x2F;&#x2F;window</span><br><span class="line">      new Vehicle(); &#x2F;&#x2F; Vehicle这个new出来的对象</span><br></pre></td></tr></table></figure>

</code></pre>
</li>
<li>
<p>面向对象中有说明new工作的简单过程</p>
</li>
</ul>
<h3 id="箭头函数"><a class="header-anchor" href="#箭头函数">¶</a>箭头函数</h3>
<ul>
<li>
<p>箭头函数中this的特点</p>
</li>
<li>
<pre><code class="language-javascript">
    window.name = 'win';
    const obj1 = {
        name: 'joy',
        getName: () =&gt; {
            console.log(this); //window 调用前this是什么函数里面的this就是什么
            console.log(this.name); //win 
        }
    };
    obj1.getName();

// 当多种方式冲突时 优先级：箭头函数 &gt; new &gt; 显式 &gt; 隐式 &gt; 默认绑定

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 用于解决保存this的问题</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## 三目运算符</span><br><span class="line"></span><br><span class="line">- 相当于 if else</span><br><span class="line"></span><br><span class="line">- &#96;&#96;&#96;javascript</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 条件表达式?行为1:行为2  如果条件表达式为true 执行行为1 false 执行行为2</span><br></pre></td></tr></table></figure>

</code></pre>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/07/15/js%E7%9A%84%E4%B8%80%E4%BA%9B%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%EF%BC%88%E6%9F%A5%E7%BC%BA%E8%A1%A5%E6%BC%8F%EF%BC%89/" data-id="ckco90n8f000328vpe7zr29fy" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JavaScript/" rel="tag">JavaScript</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-JSON" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/07/15/JSON/" class="article-date">
  <time datetime="2020-07-15T01:45:50.000Z" itemprop="datePublished">2020-07-15</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/07/15/JSON/">JSON</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>[TOC]</p>
<h2 id="JSON"><a class="header-anchor" href="#JSON">¶</a>JSON</h2>
<h3 id="语法"><a class="header-anchor" href="#语法">¶</a>语法</h3>
<ul>
<li><code>JSON</code>的语法可以表示为以下三种类型的值</li>
<li>简单值：使用与<code>JavaScript</code>相同的语法  可以在<code>JSON</code>中表示字符串、数值、布尔值、<code>null</code>  但<code>JSON</code>不支持<code>undefined</code></li>
<li>对象：对象表示一组无序的键值对  每个键对应的值可以是简单值  也可以是复杂的数据类型</li>
<li>数组：数组表示一组有序的值的列表  可以通过数值索引来访问其中的值  数组的值也可以是任意类型</li>
<li>JSON不支持变量、函数、对象实例  它是一种表示结构化数据的格式</li>
</ul>
<h4 id="简单值"><a class="header-anchor" href="#简单值">¶</a>简单值</h4>
<ul>
<li>
<pre><code class="language-json">
'hello' 1 

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 字符串、数值、布尔值、&#96;null&#96;</span><br><span class="line"></span><br><span class="line">#### 对象</span><br><span class="line"></span><br><span class="line">- 对象的属性必须加双引号</span><br><span class="line"></span><br><span class="line">- &#96;&#96;&#96;json</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; JSON没有变量声明  没有分号  </span><br><span class="line">  &#123;</span><br><span class="line">      &quot;name&quot;: &quot;a&quot;,</span><br><span class="line">      &quot;age&quot;: 10,</span><br><span class="line">      &quot;school&quot;: &#123;</span><br><span class="line">          &quot;name&quot;: &quot;nhzx&quot;,</span><br><span class="line">          &quot;location&quot;: &quot;nh&quot;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

</code></pre>
</li>
<li>
<p>同一个对象不可以出现两个同名属性</p>
</li>
</ul>
<h4 id="数组"><a class="header-anchor" href="#数组">¶</a>数组</h4>
<ul>
<li>
<p>数组的值也可以是任意类型</p>
</li>
<li>
<pre><code class="language-json">
[
    {},
    {},
    ...
]

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">  </span><br><span class="line">- 嵌套的情况也很常见</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 解析与序列化</span><br><span class="line"></span><br><span class="line">- &#96;JSON&#96;可以解析为JavaScript对象  可以简单地提取数据</span><br><span class="line"></span><br><span class="line">- &#96;&#96;&#96;javascript</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; JSON.stringify(序列化的对象,过滤器,选项) 将对象序列化为JSON字符串</span><br><span class="line">  &#x2F;&#x2F; 过滤器可以是数组（结果只返回数组中列出且对象中有的属性）  也可以是函数（详见下例）</span><br><span class="line">  &#x2F;&#x2F; 选项可以是数值（代表缩进的空格数 先换行后缩进）  也可以是字符串（字符串内可以是制表符或多段- 该字符会替代空格作为缩进前的字符）</span><br><span class="line">  &#x2F;&#x2F; 在序列化js对象时 所有函数、原型成员、值为undefined的属性都会被忽略  </span><br><span class="line">  var 序列化对象&#x3D;&#123;</span><br><span class="line">      &quot;属性1&quot;: 值1，</span><br><span class="line">      &quot;属性2&quot;: 值2</span><br><span class="line">  &#125;</span><br><span class="line">  var 变量&#x3D;JSON.stringify(序列化的对象,function(key,value)&#123;</span><br><span class="line">      switch(key)&#123;</span><br><span class="line">          case &quot;属性1&quot;:</span><br><span class="line">              return 值3;</span><br><span class="line">          case &quot;属性2&quot;:</span><br><span class="line">              return 值4;</span><br><span class="line">          ...</span><br><span class="line">          &#x2F;&#x2F; 遍历对象 每次遍历调用该函数</span><br><span class="line">          &#x2F;&#x2F; key为序列化对象的键名  value为键对应的值</span><br><span class="line">          &#x2F;&#x2F; 当次的返回值为对应键的值</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  console.log(变量) &#x2F;&#x2F; &#123;&quot;属性1&quot;: 值3，&quot;属性2&quot;: 值4&#125;</span><br><span class="line">  </span><br><span class="line">  &#x2F;&#x2F; toJSON()  可以在序列化对象中定义一个toJSON的方法  当序列化该对象时 只会调用toJSON方法  该方法的返回值为结果</span><br><span class="line">  var 序列化对象&#x3D;&#123;</span><br><span class="line">      toJSON: function()&#123;</span><br><span class="line">          return &#39;a&#39;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  var 变量&#x3D;JSON.stringify(序列化对象)</span><br><span class="line">  console.log(变量) &#x2F;&#x2F; &quot;a&quot;</span><br><span class="line">      </span><br><span class="line">  &#x2F;&#x2F; 序列化对象的顺序  （1）如果存在toJSON()方法且可以返回值  调用该方法 否则返回对象本身</span><br><span class="line">  &#x2F;&#x2F; （2）如果提供了过滤器  将（1）中的返回值传入函数过滤器中或根据数组过滤器进行序列化</span><br><span class="line">  &#x2F;&#x2F; （3）如果为函数过滤器  则对（2）返回的每个值进行序列化</span><br><span class="line">  &#x2F;&#x2F; （4）如果提供第三个参数  执行相应的格式化</span><br><span class="line">      </span><br><span class="line">  &#x2F;&#x2F; JSON.parse(JSON值,函数过滤器)  将JSON字符串解析为原生js值  函数过滤器与上述相同</span><br><span class="line">  var 变量&#x3D;JSON.parse(JSON值,function(key,value)&#123;</span><br><span class="line">      ...</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure>



</code></pre>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/07/15/JSON/" data-id="ckco90n88000028vp1rhw1ga0" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JavaScript/" rel="tag">JavaScript</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-面向对象" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/07/15/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/" class="article-date">
  <time datetime="2020-07-15T01:44:59.000Z" itemprop="datePublished">2020-07-15</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/07/15/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/">面向对象</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>[TOC]</p>
<h2 id="面向对象"><a class="header-anchor" href="#面向对象">¶</a>面向对象</h2>
<h3 id="理解对象"><a class="header-anchor" href="#理解对象">¶</a>理解对象</h3>
<ul>
<li>
<pre><code class="language-javascript">
// 两种创建对象的简单方法
// 第一种
var person=new Object()
person.name=''
person.age=1
person.sayHello=function(){
    console.log('hello')
}
// 第二种
var person={
    name: '',
    age: 1,
    sayHello: function(){
        console.log('hello')
    }
}

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">  </span><br><span class="line">- 可以通过多种方式来创建对象</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#### 属性类型</span><br><span class="line"></span><br><span class="line">##### 数据属性</span><br><span class="line"></span><br><span class="line">- 对象属性的某些性质</span><br><span class="line"></span><br><span class="line">- &#96;&#96;&#96;javascript</span><br><span class="line"></span><br><span class="line">  var 对象&#x3D;&#123;&#125;</span><br><span class="line">  Object.defineProperty(对象,&#39;属性&#39;,&#123;</span><br><span class="line">    &#x2F;&#x2F; 表示能否通过delete删除属性 能否修改属性的特性 能否把属性修改为访问器属性  默认 true</span><br><span class="line">      configurable: bool,</span><br><span class="line">    &#x2F;&#x2F; 表示能否通过for-in循环返回属性  默认true</span><br><span class="line">      enumerable: bool,</span><br><span class="line">    &#x2F;&#x2F; 表示能否修改属性的值  默认true</span><br><span class="line">      writable: bool,</span><br><span class="line">    &#x2F;&#x2F; 设置属性的值</span><br><span class="line">      valeu: 属性值</span><br><span class="line">  &#125;)</span><br><span class="line">  &#x2F;&#x2F; 当configurable为false时  不能通过上述方法修改属性的特性了</span><br></pre></td></tr></table></figure>



</code></pre>
</li>
</ul>
<h5 id="访问器属性"><a class="header-anchor" href="#访问器属性">¶</a>访问器属性</h5>
<ul>
<li>
<p>对象属性的某些性质</p>
</li>
<li>
<pre><code class="language-javascript">
var 对象={}
Object.defineProperty(对象,'属性',{
  // 表示能否通过delete删除属性 能否修改属性的特性 能否把属性修改为访问器属性  默认 true
    configurable: bool,
  // 表示能否通过for-in循环返回属性  默认true
    enumerable: bool,
  // 当读取属性的值时 会调用此函数  默认undefined  函数的返回值决定了读取到的值
    get: function(){
        
    }
  // 当设置属性的值时  会调用此函数  函数的返回值决定了设置的值
    set: function(){
    
	}
})

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#### 定义多个属性</span><br><span class="line"></span><br><span class="line">- 修改多个属性的性质</span><br><span class="line"></span><br><span class="line">- &#96;&#96;&#96;javascript</span><br><span class="line"></span><br><span class="line">  var 对象&#x3D;&#123;&#125;</span><br><span class="line">  Object.defineProperties(对象, &#123;</span><br><span class="line">      属性1: &#123;</span><br><span class="line">  		添加数据属性的特性或访问器属性的特性</span><br><span class="line">      &#125;,</span><br><span class="line">      属性2: &#123;</span><br><span class="line">  		添加数据属性的特性或访问器属性的特性</span><br><span class="line">      &#125;,</span><br><span class="line">      属性3: &#123;</span><br><span class="line">  		添加数据属性的特性或访问器属性的特性</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  &#x2F;&#x2F; 添加不同属性的特性决定了改属性是访问器属性还是数据属性</span><br></pre></td></tr></table></figure>



</code></pre>
</li>
</ul>
<h4 id="读取属性的特性"><a class="header-anchor" href="#读取属性的特性">¶</a>读取属性的特性</h4>
<ul>
<li>
<p>读取属性的特性</p>
</li>
<li>
<pre><code class="language-javascript">
var 对象={}
Object.defineProperties(对象, {
    属性1: {
		value: 1,
        enumerable: false
    }
})
var 变量=Object.getOwnPropertyDescriptor(对象, '属性1')
变量.value  // 1
变量.enumerable  // false

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 创建对象</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#### 工厂模式</span><br><span class="line"></span><br><span class="line">- 将创建对象的过程封装为一个函数</span><br><span class="line"></span><br><span class="line">- &#96;&#96;&#96;javascript</span><br><span class="line"></span><br><span class="line">  function creat(name,age)&#123;</span><br><span class="line">      var o&#x3D;new Object()</span><br><span class="line">      o.name&#x3D;name</span><br><span class="line">      o.age&#x3D;age</span><br><span class="line">      return o;</span><br><span class="line">  &#125;</span><br><span class="line">  var person1&#x3D;creat(&#39;a&#39;,1)</span><br><span class="line">  var person2&#x3D;creat(&#39;b&#39;,2)</span><br><span class="line">  &#x2F;&#x2F; 工厂模式解决了创建多个类似对象的问题  但没有解决对象识别的问题（即辨别对象的类型）</span><br></pre></td></tr></table></figure>



</code></pre>
</li>
</ul>
<h4 id="构造函数模式"><a class="header-anchor" href="#构造函数模式">¶</a>构造函数模式</h4>
<ul>
<li>
<p>解决了工厂模式不可以识别对象的问题</p>
</li>
<li>
<pre><code class="language-javascript">
function Person(name,age){
    this.name=name
    this.age=age
}
var person1=Person('a',1)
var person2=Person('b',2)
// 特点： 没有显示地创建对象  直接将属性和方法赋给了this对象  没有return

// 创建Person实例需要调用new操作符  这种调用构造函数的方式经历了下列步骤
// （1）创建新对象  （2）将构造函数的作用域赋给新对象   （3）执行代码  （4）返回新对象

person1.constructor == Person //true
person1 instanceof Object // true
person1 instanceof Person // true

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 构造函数的特点</span><br><span class="line"></span><br><span class="line">- &#96;&#96;&#96;javascript</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 构造函数与其他函数的唯一区别就是他们调用的方式不同</span><br><span class="line">  </span><br><span class="line">  &#x2F;&#x2F; 构造函数作为普通函数调用  会将属性添加到window上</span><br><span class="line">  </span><br><span class="line">  &#x2F;&#x2F; 在另一个对象的作用域调用（如 apply call）会将属性添加到该对象上</span><br><span class="line">  </span><br><span class="line">  &#x2F;&#x2F; 构造函数存在的问题：创造的对象所包含的方法是不同的function实例</span><br><span class="line">  function Person(name,age)&#123;</span><br><span class="line">      this.name&#x3D;name</span><br><span class="line">      this.age&#x3D;age</span><br><span class="line">      this.sayName&#x3D;sayName</span><br><span class="line">  &#125;</span><br><span class="line">  function sayName()&#123;</span><br><span class="line">      console.log(this.name)</span><br><span class="line">  &#125;</span><br><span class="line">  &#x2F;&#x2F; 这种方法更好</span><br></pre></td></tr></table></figure>



</code></pre>
</li>
</ul>
<h4 id="原型模式"><a class="header-anchor" href="#原型模式">¶</a>原型模式</h4>
<ul>
<li>
<p>原型模式解决了构造函数模式创建方法指向不同的问题</p>
</li>
<li>
<pre><code class="language-javascript">
// 每一个构造函数都有一个prototype属性  这个属性是一个指针  指向一个对象
// 原型对像包含了可以由特定类型的所有实例共享的属性和方法
function Person(){}
	Person.prototype.name='a'
	Person.prototype.sayName=function(){
    	console.log(this.name)
	}
var person1=new Person()
person1.sayName() // 'a'

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">##### 理解原型对象</span><br><span class="line"></span><br><span class="line">- 构造函数和实例的&#96;prototype&#96;属性指向他们的原型对象</span><br><span class="line"></span><br><span class="line">- 原型对象的&#96;constructor&#96;属性指向构造函数</span><br><span class="line"></span><br><span class="line">- 当获取对象的属性或调用方法时  如果对象没有该属性或方法  会查看对象的原型对象上是否拥有该属性或方法  如果有则获取或调用  如果没有则继续像上寻找</span><br><span class="line"></span><br><span class="line">- &#96;&#96;&#96;javascript</span><br><span class="line"></span><br><span class="line">  Person.prototype.isPrototypeOf(person1) &#x2F;&#x2F; true</span><br><span class="line">  &#x2F;&#x2F; 如果person1内部具有指向Person.prototype的指针 则返回true</span><br><span class="line">  </span><br><span class="line">  Object.getPrototypeOf(person1) &#x2F;&#x2F; Person.prototype</span><br><span class="line">  &#x2F;&#x2F; 该方法可以获取一个对象的原型对象</span><br><span class="line">  </span><br><span class="line">  &#x2F;&#x2F; 将对象上某个属性的值更改为null 也不能再通过对象属性来获取原型对象上该属性的值了</span><br><span class="line">  &#x2F;&#x2F; 只能删除该属性 才能重新获取</span><br><span class="line">  person1.name&#x3D;&#39;b&#39;</span><br><span class="line">  person1.name&#x3D;null</span><br><span class="line">  console.log(person1.name) &#x2F;&#x2F; null 不是&#39;a&#39;</span><br><span class="line">  delete person1.name</span><br><span class="line">  console.log(person1.name) &#x2F;&#x2F; &#39;a&#39;</span><br><span class="line">  </span><br><span class="line">  实例对象.hasOwnProperty(&#39;属性&#39;)</span><br><span class="line">  &#x2F;&#x2F; 判断该实例对象是否拥有该属性（可以判断该属性的值是否来源于实例对象的原型对象）</span><br></pre></td></tr></table></figure>



</code></pre>
</li>
</ul>
<h5 id="原型与in操作符（包含对象的枚举）"><a class="header-anchor" href="#原型与in操作符（包含对象的枚举）">¶</a>原型与in操作符（包含对象的枚举）</h5>
<ul>
<li>
<p>一些性质</p>
</li>
<li>
<pre><code class="language-javascript">
'属性' in 对象 // 只有该对象或原型对象上有该属性（只要通过对象能访问到该属性） 则返回true
对象.hasOwnProperty('属性') // 只有当该对象上有该属性时 才会返回true
// 利用这两个方法  可以判断出 该属性是在原型上还是在实例上或者都没有

hasPrototypeProperty(对象,'属性')
// 如果属性在原型中 则返回true 如果实例中含有该属性 则返回false

// 在使用for in循环时  返回的时所有能通过对象访问的、能枚举（enumerated）的属性
// 包含实例中的属性 也包含原型中的属性（原型中的能枚举属性）
// 在ie8及更早的浏览器中  实例对象与原型对象都拥有同一属性或方法（且该方法在原型上是不可枚举的）for in循环不会返回实例对象上的该方法或属性
var obj = {
	itemA: 'itemA',
	itemB: 'itemB'
}
var newObj = Object.create(obj) // 使用Object.create创建一个原型为obj的对象
newObj.newItemA = 'newItemA'
newObj.newItemB = 'newItemB'
Object.defineProperty(obj,'itemA',{
	enumerable: false
})

for(i in newObj){
	console.log(i)
}  // itemB newItemA newItemB

// Object.keys(对象) 可以获取对象上所有可枚举的实例属性  返回一个数组
 var obj = {
 	itemA: 'itemA',
    itemB: 'itemB'
 }
 var newObj = Object.create(obj) // 使用Object.create创建一个原型为obj的对象
 newObj.newItemA = 'newItemA'
 newObj.newItemB = 'newItemB'
 Object.defineProperty(newObj,'newItemA',{
 	enumerable: false
 })
 var result = Object.keys(newObj)
 console.log(result) // ['newItemB']

// Object.getOwnPropertyName(对象) 获取所有实例属性（包括不可枚举） 返回一个数组
 var obj = {
 	itemA: 'itemA',
	itemB: 'itemB'
}
var newObj = Object.create(obj) // 使用Object.create创建一个原型为obj的对象
newObj.newItemA = 'newItemA'
newObj.newItemB = 'newItemB'
Object.defineProperty(newObj,'newItemA',{
	enumerable: false
})
var result = Object.getOwnPropertyNames(newObj)
console.log(result) // ['newItemA','newItemB']

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">##### 更简单的原型语法</span><br><span class="line"></span><br><span class="line">- 更简单的写法（使用第二种）</span><br><span class="line"></span><br><span class="line">- &#96;&#96;&#96;javascript</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 更简单的写法  存在问题：Person的原型的构造函数不再是Person</span><br><span class="line">  function Person()&#123;</span><br><span class="line">      </span><br><span class="line">  &#125;</span><br><span class="line">  Person.prototype&#x3D;&#123;</span><br><span class="line">      name: &#39;&#39;,</span><br><span class="line">      age: 1,</span><br><span class="line">      sayName: function()&#123;</span><br><span class="line">          </span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  &#x2F;&#x2F; 解决</span><br><span class="line">  function Person()&#123;</span><br><span class="line">      </span><br><span class="line">  &#125;</span><br><span class="line">  Person.prototype&#x3D;&#123;</span><br><span class="line">      constructor: Person, &#x2F;&#x2F; 这样写会导致Person的原型中constructor变成可枚举属性（原本不可枚举）</span><br><span class="line">      name: &#39;&#39;,</span><br><span class="line">      age: 1,</span><br><span class="line">      sayName: function()&#123;</span><br><span class="line">          </span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>



</code></pre>
</li>
</ul>
<h5 id="原型的动态性"><a class="header-anchor" href="#原型的动态性">¶</a>原型的动态性</h5>
<ul>
<li>
<p>创建实例后  修改原型带来的问题</p>
</li>
<li>
<pre><code class="language-javascript">
// 在创建实例后  为原型增加或删除属性/方法 不会影响实例与原型的关系（同样共享属性方法）
// 创建实例后  将原型对象修改为另一个对象 会出现问题（新原型与实例没有任何关系 旧原型仍保持原有的属性与方法 实例指向的是旧原型）
function Person(){
    
}
var a=new Person()
Person.prototype.name='a'
Person.prototype={
    name: 'b',
    sayName: function(){
        
    }
}
a.name // 在旧原型上寻找  'a'
a.sayName() // 报错

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">##### 原生对象的原型</span><br><span class="line"></span><br><span class="line">- 可以通过增删改原生对象的原型的方式来设置原生对象上的方法（不推荐）</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">##### 原型对象的问题</span><br><span class="line"></span><br><span class="line">- 当我们对对象上没有的属性值操作（该属性在原型上 不是赋值操作） 会导致所有实例对象访问该属性时属性值都发生改变（原型对象共享的弊端）</span><br><span class="line"></span><br><span class="line">- &#96;&#96;&#96;JavaScript</span><br><span class="line"></span><br><span class="line">  function Person()&#123;</span><br><span class="line">      </span><br><span class="line">  &#125;</span><br><span class="line">  var a&#x3D;new Person()</span><br><span class="line">  var b&#x3D;new Person()</span><br><span class="line">  Person.prototype&#x3D;&#123;</span><br><span class="line">      friends: [&#39;c&#39;,&#39;d&#39;]</span><br><span class="line">  &#125;</span><br><span class="line">  a.friends.push(&#39;f&#39;)</span><br><span class="line">  console.log(a.friends) &#x2F;&#x2F; [&#39;c&#39;,&#39;d&#39;,&#39;f&#39;]</span><br><span class="line">  console.log(b.friends) &#x2F;&#x2F; [&#39;c&#39;,&#39;d&#39;,&#39;f&#39;]</span><br></pre></td></tr></table></figure>



</code></pre>
</li>
</ul>
<h4 id="组合使用构造函数与原型"><a class="header-anchor" href="#组合使用构造函数与原型">¶</a>组合使用构造函数与原型</h4>
<ul>
<li>
<p>更好地设置实例属性  共享方法</p>
</li>
<li>
<pre><code class="language-javascript">
// 正确做法
function Person(name,age){
    this.name=name
    this.age=age
}
Person.prototype={
    constructor: Person,
    sayName: function(){
        console.log(this.name)
    }
}
var p1=new Person('',2)

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#### 动态原型模式</span><br><span class="line"></span><br><span class="line">- 在构造函数内部设置原型的方法</span><br><span class="line"></span><br><span class="line">- &#96;&#96;&#96;javascript</span><br><span class="line"></span><br><span class="line">  function Person(name,age)&#123;</span><br><span class="line">      this.name&#x3D;name</span><br><span class="line">      this.age&#x3D;age</span><br><span class="line">      if(typeof this.sayName!&#x3D;&#39;function&#39;)&#123;</span><br><span class="line">          Person.prototype.sayName&#x3D;function()&#123; </span><br><span class="line">          	console.log(this.name)</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  var p1&#x3D;new Person(&#39;&#39;,2)</span><br></pre></td></tr></table></figure>



</code></pre>
</li>
</ul>
<h4 id="寄生构造函数模式"><a class="header-anchor" href="#寄生构造函数模式">¶</a>寄生构造函数模式</h4>
<ul>
<li>
<p>除了使用new操作符外  与工厂模式一致</p>
</li>
<li>
<pre><code class="language-javascript">
// 在可以使用其他模式时不要使用这种模式
// 返回的对象与构造函数或者构造函数的原型之间没有关系
function Person(name,age){
    var o=new Object()
    o.name=name
    o.age=age
    o.sayName=function(){
        
    }
    return o
}
var a=new Person('',1)
a instanceof Person // false
a.prototype==Person.prototype // false

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#### 稳妥构造函数模式</span><br><span class="line"></span><br><span class="line">- 类似与命名空间</span><br><span class="line"></span><br><span class="line">- &#96;&#96;&#96;javascript</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 与命名空间类似  私有变量与函数没有办法从外部查看  外部只能使用该对象暴露的方法</span><br><span class="line">  function Person(name,age)&#123;</span><br><span class="line">      var o&#x3D;new Object()</span><br><span class="line">      &#x2F;&#x2F; 定义私有变量与函数</span><br><span class="line">      o.方法1&#x3D;function()&#123;</span><br><span class="line">          &#x2F;&#x2F; 操作</span><br><span class="line">      &#125;</span><br><span class="line">      o.方法2&#x3D;function()&#123;</span><br><span class="line">          &#x2F;&#x2F; 操作</span><br><span class="line">      &#125;</span><br><span class="line">      ...</span><br><span class="line">      return o</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>



</code></pre>
</li>
</ul>
<h3 id="继承"><a class="header-anchor" href="#继承">¶</a>继承</h3>
<ul>
<li>许多<code>OO</code>语言都支持两种继承方式：接口继承和实现继承  接口继承只继承方法签名  实现继承则继承实际的方法</li>
<li>JavaScript只支持实现继承</li>
</ul>
<h4 id="原型链"><a class="header-anchor" href="#原型链">¶</a>原型链</h4>
<ul>
<li>
<p>实现继承的基础</p>
</li>
<li>
<pre><code class="language-javascript">
function SuperType(){ 
	this.property = true; 
}
SuperType.prototype.getSuperValue = function(){ 
	return this.property; 
}; 
function SubType(){ 
	this.subproperty = false; 
} 
//继承了 SuperType 
SubType.prototype = new SuperType(); 
SubType.prototype.getSubValue = function (){ 
	return this.subproperty; 
}; 
var instance = new SubType(); 
alert(instance.getSuperValue()); // true
// 上述搜索会经历三个步骤 （1）搜索实例  （2）搜索SubType.prototype  （3）搜索SuperType.prototype

// 所有的函数的默认原型都是Object的实例  因此默认原型都指向Object.prototype

// 可以通过instanceof和isPrototypeof()来确定原型与实例之间的关系
原型对象.isPrototypeof(实例)  

// 给原型添加的代码一定要放在替换原型的语句之后

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#### 借用构造函数</span><br><span class="line"></span><br><span class="line">- 继承属性</span><br><span class="line"></span><br><span class="line">- &#96;&#96;&#96;javascript</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 利用call方法在构造函数内部调用其他构造函数  **可以继承它的属性**</span><br><span class="line">  function SuperType(name)&#123; </span><br><span class="line">  	this.name &#x3D; name; </span><br><span class="line">  &#125; </span><br><span class="line">  function SubType()&#123; </span><br><span class="line">  	&#x2F;&#x2F; 继承了 SuperType，同时还传递了参数</span><br><span class="line">  	SuperType.call(this, &quot;Nicholas&quot;); </span><br><span class="line">  	&#x2F;&#x2F; 实例属性</span><br><span class="line">  	this.age &#x3D; 29; </span><br><span class="line">  &#125; </span><br><span class="line">  var instance &#x3D; new SubType(); </span><br><span class="line">  console.log(instance.name); &#x2F;&#x2F;&quot;Nicholas&quot;; </span><br><span class="line">  console.loginstance.age); &#x2F;&#x2F;29</span><br><span class="line">  console.log(instance instanceof SuperType) &#x2F;&#x2F;false</span><br></pre></td></tr></table></figure>



</code></pre>
</li>
</ul>
<h4 id="组合继承"><a class="header-anchor" href="#组合继承">¶</a>组合继承</h4>
<ul>
<li>
<p>继承属性及方法</p>
</li>
<li>
<pre><code class="language-JavaScript">
// 常用的继承模式
function SuperType(name){ 
	this.name = name; 
	this.colors = [&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;]; 
} 
SuperType.prototype.sayName = function(){ 
	alert(this.name);
}; 
function SubType(name, age){ 
	// 继承属性
	SuperType.call(this, name);  
 	this.age = age; 
} 
// 继承方法 产生联系（constructor prototype）
SubType.prototype = new SuperType(); 
SubType.prototype.constructor = SubType; 
// 添加自己独有的方法
SubType.prototype.sayAge = function(){ 
	alert(this.age); 
}; 
// 创建两个实例验证
var instance1 = new SubType(&quot;Nicholas&quot;, 29); 
instance1.colors.push(&quot;black&quot;); 
alert(instance1.colors); //&quot;red,blue,green,black&quot; 
instance1.sayName(); //&quot;Nicholas&quot;; 
instance1.sayAge(); //29 
var instance2 = new SubType(&quot;Greg&quot;, 27); 
alert(instance2.colors); //&quot;red,blue,green&quot; 
instance2.sayName(); //&quot;Greg&quot;; 
instance2.sayAge(); //27

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#### 原型式继承</span><br><span class="line"></span><br><span class="line">- 继承属性及方法（本质为浅克隆）</span><br><span class="line"></span><br><span class="line">- &#96;&#96;&#96;javascript</span><br><span class="line"></span><br><span class="line">  function object(o)&#123; </span><br><span class="line">  	function F()&#123;&#125; </span><br><span class="line">  	F.prototype &#x3D; o; </span><br><span class="line">  	return new F(); </span><br><span class="line">  &#125; &#x2F;&#x2F; 继承了传入对象的属性与方法</span><br><span class="line">  &#x2F;&#x2F; 本质上这种方法就是对传入的对象执行了一次浅复制 与Object.creat()传入一个参数是相同</span><br></pre></td></tr></table></figure>



</code></pre>
</li>
</ul>
<h4 id="寄生式继承"><a class="header-anchor" href="#寄生式继承">¶</a>寄生式继承</h4>
<ul>
<li>
<p>继承属性及方法  还可以添加新的属性和方法</p>
</li>
<li>
<pre><code class="language-javascript">
// 创建一种用于封装继承过程的函数  在函数内部以某种方式来增强对象
function createAnother(original){ 
	var clone = Object.creat(original); // 通过调用函数创建一个新对象(可以使用任何能够返回新对象的方式 这里只是一个例子)
	clone.sayHi = function(){ // 以某种方式来增强这个对象
		alert(&quot;hi&quot;); 
	}
	return clone; // 返回这个对象
}
// 继承了传入对象的属性与方法 并且为其添加了新的属性或方法

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#### 寄生组合式继承</span><br><span class="line"></span><br><span class="line">- 一个实例对象继承了一个原型的属性与方法（并且是另一个原型的实例）</span><br><span class="line"></span><br><span class="line">- &#96;&#96;&#96;javascript</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; （1）创建超类型原型的一个副本  （2）为创建的副本添加constructor属性 弥补因原型重写而失去的默认constructor属性  （3）将创建的副本赋值给子类型的原型</span><br><span class="line">  &#x2F;&#x2F; SubType.prototype &#x3D; new SuperType(); 会调用两次SuperType</span><br><span class="line">  &#x2F;&#x2F; 下列方法可以只调用一次超类的构造函数</span><br><span class="line">  function inheritPrototype(subType, superType)&#123; </span><br><span class="line">  	var prototype &#x3D; object.creat(superType.prototype); &#x2F;&#x2F;创建对象</span><br><span class="line">  	prototype.constructor &#x3D; subType; &#x2F;&#x2F;增强对象</span><br><span class="line">  	subType.prototype &#x3D; prototype; &#x2F;&#x2F;指定对象</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  &#x2F;&#x2F; 最好的方法</span><br><span class="line">  function SuperType(name)&#123;  &#x2F;&#x2F; 创建构造函数1</span><br><span class="line">  	this.name &#x3D; name; </span><br><span class="line">  	this.colors &#x3D; [&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;]; </span><br><span class="line">  &#125; </span><br><span class="line">  SuperType.prototype.sayName &#x3D; function()&#123; &#x2F;&#x2F; 为构造函数1的原型添加方法（添加实例1的共享方法）</span><br><span class="line">  	alert(this.name); </span><br><span class="line">  &#125;; </span><br><span class="line">  function SubType(name, age)&#123; &#x2F;&#x2F; 创建构造函数2 创建自己的属性与方法</span><br><span class="line">  	SuperType.call(this, name); </span><br><span class="line">  	this.age &#x3D; age; </span><br><span class="line">  &#125; </span><br><span class="line">  function inheritPrototype(subType, superType)&#123;  </span><br><span class="line">  	var prototype &#x3D; Object.creat(superType.prototype); &#x2F;&#x2F; 创建构造函数1的原型的副本（即继承构造函数1的原型的方法）</span><br><span class="line">  	prototype.constructor &#x3D; subType; &#x2F;&#x2F; 建立副本与构造函数2的关系（prototype constructor）</span><br><span class="line">  	subType.prototype &#x3D; prototype;</span><br><span class="line">  &#125;</span><br><span class="line">  inheritPrototype(SubType, SuperType); </span><br><span class="line">  SubType.prototype.sayAge &#x3D; function()&#123; &#x2F;&#x2F; 为副本添加方法</span><br><span class="line">  	alert(this.age); </span><br><span class="line">  &#125;;</span><br><span class="line">  &#x2F;&#x2F; 结果：实例2可以使用拥有自己的方法 也继承了实例1的方法</span><br></pre></td></tr></table></figure>



</code></pre>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/07/15/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/" data-id="ckco90n8g000428vp2i66dl5d" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JavaScript/" rel="tag">JavaScript</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="[post]-git初学" class="article article-type-[post]" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/07/13/git%E5%88%9D%E5%AD%A6/" class="article-date">
  <time datetime="2020-07-13T08:38:28.000Z" itemprop="datePublished">2020-07-13</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/07/13/git%E5%88%9D%E5%AD%A6/">git初学</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>[TOC]</p>
<h2 id="git"><a class="header-anchor" href="#git">¶</a>git</h2>
<h3 id="工作流程"><a class="header-anchor" href="#工作流程">¶</a>工作流程</h3>
<h4 id="workspace-工作区"><a class="header-anchor" href="#workspace-工作区">¶</a>workspace (工作区)</h4>
<ul>
<li>程序员进行开发改动的地方  是你当前看到的  也是最新的</li>
<li>平常我们进行开发就是拷贝远程仓库中的一个分支  基于该分支进行开发  在开发过程中就是对工作区的操作</li>
</ul>
<h4 id="index-stage-暂存区"><a class="header-anchor" href="#index-stage-暂存区">¶</a>index/stage(暂存区)</h4>
<ul>
<li>.git目录下的index文件  暂存区会记录<code>git add</code>添加文件的相关信息(文件名、大小、<code>timestamp</code>…)  不报存文件实体  通过<code>id</code>指向每个文件实体</li>
<li>可以使用<code>git status</code>查看暂存区的状态 暂存区标记了你当前工作区中 哪些内容是被<code>git</code>管理的</li>
<li>当你完成某个需求或功能后需要提交到远程仓库  那么第一步就是通过<code>git add</code>先提交到暂存区 被<code>git</code>管理</li>
</ul>
<h4 id="repository-本地仓库"><a class="header-anchor" href="#repository-本地仓库">¶</a>repository(本地仓库)</h4>
<ul>
<li>保存了对象被提交过的各个版本  比起工作区和暂存区的内容  它要更旧些</li>
<li><code>git commit</code>后同步index的目录树到本地仓库  方便从下一步通过<code>git push</code>同步本地仓库与远程仓库的同步</li>
</ul>
<h4 id="remote-远程仓库"><a class="header-anchor" href="#remote-远程仓库">¶</a>remote(远程仓库)</h4>
<ul>
<li>远程仓库的内容可能被分布在多个地点的处于协作关系的本地仓库修改  因此它可能与本地仓库同步  也可能不同步  但是它的内容是最旧的</li>
</ul>
<h4 id="小结"><a class="header-anchor" href="#小结">¶</a>小结</h4>
<ul>
<li>（1）任何对象都是在工作区中诞生和被修改</li>
<li>（2）任何修改都是从进入<code>index</code>区才开始被版本控制</li>
<li>（3）只有把修改提交到本地仓库  该修改才能在仓库中留下痕迹</li>
<li>（4）与协作者分享本地的修改  可以把他们<code>push</code>到远程仓库来共享</li>
</ul>
<h3 id="常用git命令"><a class="header-anchor" href="#常用git命令">¶</a>常用git命令</h3>
<h4 id="HEAD"><a class="header-anchor" href="#HEAD">¶</a>HEAD</h4>
<ul>
<li><code>HEAD</code> 它始终指向当前所处分支的最新的提交的</li>
<li>你所处的分支变化了  或者产生了新的提交点  <code>HEAD</code>就会跟着改变</li>
</ul>
<h4 id="add"><a class="header-anchor" href="#add">¶</a>add</h4>
<ul>
<li><code>add</code>相关命令主要实现将工作区修改的内容提交到暂存区  交给<code>git</code>管理</li>
<li><code>git add</code> 添加当前目录的所有文件到暂存区</li>
<li><code>git add &lt;dir&gt;</code> 添加指定目录到暂存区  包括子目录  例：<code>git add readme.md</code></li>
<li><code>git add &lt;file1&gt;</code>  添加指定文件到暂存区  例：<code>git add 文件名</code></li>
</ul>
<h4 id="commit"><a class="header-anchor" href="#commit">¶</a>commit</h4>
<ul>
<li><code>commit</code>相关命令主要实现将暂存区的内容提交到本地仓库  并使当前分支的<code>HEAD</code>向后移动一个提交点</li>
<li><code>git commit -m &lt;message&gt;</code>  提交暂存区到本地仓库  message说明信息</li>
<li><code>git commit &lt;file1&gt; -m &lt;message&gt;</code> 提交暂存区的指定文件到本地仓库  例：<code>git commit 文件.后缀 -m &quot;说明&quot;</code></li>
<li><code>git commit --amend -m &lt;message&gt;</code> 使用一次新的<code>commit</code>  替代上次提交</li>
</ul>
<h4 id="branch"><a class="header-anchor" href="#branch">¶</a>branch</h4>
<ul>
<li><code>git branch</code>    列出所有本地分支</li>
<li><code>git branch -r</code>  列出所有远程分支</li>
<li><code>git branch-a</code>  列出所有本地分支和远程分支</li>
<li><code>git branch &lt;branch-name&gt;</code>  新建一个分支  但仍停留在当前分支  例：<code>git branch 分支名</code></li>
<li><code>git checkout -b &lt;branch-name&gt;</code>  新建一个分支并切换到该分支</li>
<li><code>git branch --track &lt;branch&gt; &lt;remote-branch&gt;</code>  新建一个分支  与指定的远程分支建立追踪关系</li>
<li><code>git checkout &lt;branch-name&gt;</code>  切换到指定分支并更新工作区</li>
<li><code>git branch -d &lt;branch-name&gt;</code>  删除分支</li>
<li><code>git push origin --delete &lt;branch-name&gt;</code>  删除远程分支</li>
</ul>
<h4 id="merge"><a class="header-anchor" href="#merge">¶</a>merge</h4>
<ul>
<li>merge命令把不同的分支合并起来</li>
<li><code>git fetch &lt;remote&gt;</code>  <code>merge</code>之前先拉一下远程仓库最新代码</li>
<li><code>git merge &lt;branch&gt;</code>  合并指定分支到当前分支  例：<code>git merge 分支名</code></li>
<li>一般在<code>merge</code>之后  会出现<code>conflict</code> 需要针对冲突情况  手动解决冲突  主要是因为两个用户修改了同一文件的同一块区域</li>
</ul>
<h4 id="rebase"><a class="header-anchor" href="#rebase">¶</a>rebase</h4>
<ul>
<li><code>rebase</code>称为衍合  是合并的另外一种选择</li>
<li>在开始阶段  我们处于new分支上  执行<code>git rebase dev</code>  那么<code>new</code>分支上新的<code>commit</code>都在<code>master</code>分支上重演一遍  最后<code>checkout </code>切换回<code>new</code>分支  这点和<code>merge</code>是一样的  合并前后所处的分支没有改变</li>
<li><code>git rebase dev</code> <code>new</code>分支想要站在dev的肩膀上继续下去  <code>rebase</code>  也需要手动解决冲突</li>
</ul>
<h5 id="rebase与merge的区别"><a class="header-anchor" href="#rebase与merge的区别">¶</a>rebase与merge的区别</h5>
<ul>
<li>
<pre><code>初始状态
     D---E test
     /
A---B---C---F master

在 master 执行 git merge test 后
      D--------E
     /          \
A---B---C---F----G   test, master

在 master 执行 git rebase test 后
A---B---D---E---C'---F'   test, master
</code></pre>
</li>
<li>
<p><code>merge</code>操作会生成一个新的节点  之前的提交分开显示  而<code>rebase</code>不会生成新的节点  是将两个分支融合成一个线性的提交</p>
</li>
<li>
<p>如果想要一个干净 没有<code>merge commit</code>的线性历史树  使用<code>rebase</code></p>
</li>
<li>
<p>如果想要保留完整的历史记录  并且避免重写<code>commit history</code>的风险  使用<code>merge</code></p>
</li>
</ul>
<h4 id="reset"><a class="header-anchor" href="#reset">¶</a>reset</h4>
<ul>
<li><code>reset</code>命令把当前分支指向另一个位置  并且相应的变动工作区和暂存区</li>
<li><code>git reset ——soft &lt;commit&gt;</code>  只改变提交点  暂存区和工作目录的内容都不变</li>
<li><code>git reset ——mixed &lt;commit&gt;</code> 改变提交点  同时改变暂存区的内容</li>
<li><code>git reset ——hard &lt;commit&gt;</code> 暂存区 工作区的内容都会被修改到与提交点完全一致的状态</li>
<li><code>git reset ——hard HEAD</code> 让工作区回到上次提交时的状态</li>
</ul>
<h4 id="revert"><a class="header-anchor" href="#revert">¶</a>revert</h4>
<ul>
<li><code>git revert</code> 用一个新提交来消除一个历史提交所做的任何修改</li>
</ul>
<h5 id="revert和reset的区别"><a class="header-anchor" href="#revert和reset的区别">¶</a>revert和reset的区别</h5>
<ul>
<li><code>git revert</code>是用一次新的<code>commit</code>来回滚之前的<code>commit</code> <code>git reset</code>是直接删除指定的<code>commit</code>。</li>
<li>在回滚这一操作上看，效果差不多。但是在日后继续<code>merge</code>以前的老版本时有区别。因为<code>git revert</code>是用一次逆向的<code>commit</code>中和之前的提交，因此日后合并老的<code>branch</code>时，导致这部分改变不会再次出现，减少冲突。但是<code>git reset</code>是之间把某些<code>commit</code>在某个<code>branch</code>上删除，因而和老的<code>branch</code>再次<code>merge</code>时，这些被回滚的<code>commit</code>应该还会被引入，产生很多冲突。</li>
<li><code>git reset </code>是把<code>HEAD</code>向后移动了一下，而<code>git revert</code>是<code>HEAD</code>继续前进，只是新的<code>commit</code>的内容和要<code>revert</code>的内容正好相反，能够抵消要被<code>revert</code>的内容。</li>
</ul>
<h4 id="push"><a class="header-anchor" href="#push">¶</a>push</h4>
<ul>
<li>本地仓库分支到远程仓库分支  实现同步</li>
<li><code>git push &lt;remote&gt; &lt;branch&gt;</code>  上次本地指定分支到远程仓库</li>
<li><code>git push &lt;remote&gt; --force</code>  强行推送当前分支到远程仓库  即使有冲突</li>
<li><code>git push &lt;remote&gt; --all</code> 推送所有分支到远程仓库</li>
</ul>
<h4 id="其他命令"><a class="header-anchor" href="#其他命令">¶</a>其他命令</h4>
<ul>
<li><code>git status</code> 显示有变更的文件</li>
<li><code>git log</code> 显示当前分支的版本历史</li>
<li><code>git diff</code> 显示暂存区和工作区的差异</li>
<li><code>git diff HEAD</code>  显示工作区与当前分支最新<code>commit</code>之间的差异</li>
<li><code>git cherry-pick &lt;commit&gt;</code> 选择一个<code>commit</code> 合并进当前分支</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/07/13/git%E5%88%9D%E5%AD%A6/" data-id="ckco90n8c000128vp8lqn0lx6" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/git/" rel="tag">git</a></li></ul>

    </footer>
  </div>
  
</article>


  


</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/JavaScript/" rel="tag">JavaScript</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/es6/" rel="tag">es6</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/git/" rel="tag">git</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/JavaScript/" style="font-size: 20px;">JavaScript</a> <a href="/tags/es6/" style="font-size: 15px;">es6</a> <a href="/tags/git/" style="font-size: 10px;">git</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/07/">July 2020</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2020/07/18/Iterator%E5%92%8Cfor-of%E5%BE%AA%E7%8E%AF/">Iterator和for...of循环</a>
          </li>
        
          <li>
            <a href="/2020/07/16/%E4%BB%A3%E7%90%86%E4%B8%8E%E5%8F%8D%E5%B0%84/">代理与反射</a>
          </li>
        
          <li>
            <a href="/2020/07/15/js%E7%9A%84%E4%B8%80%E4%BA%9B%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%EF%BC%88%E6%9F%A5%E7%BC%BA%E8%A1%A5%E6%BC%8F%EF%BC%89/">js的一些基础知识（查缺补漏）</a>
          </li>
        
          <li>
            <a href="/2020/07/15/JSON/">JSON</a>
          </li>
        
          <li>
            <a href="/2020/07/15/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/">面向对象</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2020 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>




  </div>
</body>
</html>